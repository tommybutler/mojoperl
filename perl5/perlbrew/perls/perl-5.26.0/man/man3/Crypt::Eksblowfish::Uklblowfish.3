.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Crypt::Eksblowfish::Uklblowfish 3"
.TH Crypt::Eksblowfish::Uklblowfish 3 "2018-08-13" "perl v5.26.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::Eksblowfish::Uklblowfish \- Blowfish cipher with unrestricted key length
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Crypt::Eksblowfish::Uklblowfish;
\&
\&        $block_size = Crypt::Eksblowfish::Uklblowfish\->blocksize;
\&        $key_size = Crypt::Eksblowfish::Uklblowfish\->keysize;
\&
\&        $cipher = Crypt::Eksblowfish::Uklblowfish\->new($key);
\&
\&        $block_size = $cipher\->blocksize;
\&        $ciphertext = $cipher\->encrypt($plaintext);
\&        $plaintext = $cipher\->decrypt($ciphertext);
\&
\&        $p_array = $cipher\->p_array;
\&        $s_boxes = $cipher\->s_boxes;
\&        if($cipher\->is_weak) { ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of this type encapsulates a keyed instance of the Blowfish
block cipher, ready to encrypt and decrypt.  However, if you're
looking for an implementation of Blowfish you most likely want
Crypt::Eksblowfish::Blowfish.  This class differs from the standard
Blowfish in that it accepts some keys that Blowfish officially does
not permit.
.PP
Blowfish is a symmetric cipher algorithm designed by Bruce Schneier in
1993.  It operates on 64\-bit blocks, and takes a variable-length key.
Officially the key can vary from 32 bits (4 octets) to 448 bits (56
octets) in increments of 8 bits (1 octet).  In fact the algorithm can
easily operate on a key of any number of octets from 1 (8 bits) to 72
(576 bits).  Some implementations don't enforce the official key length
limits, and so for compatibility it is sometimes necessary to handle a
Blowfish key of a prohibited length.  That is what this class is for.
The \*(L"Ukl\*(R" in the name stands for \*(L"unrestricted key length\*(R".
.PP
Using a very short key is generally a bad idea because there aren't
very many keys of that length and so it's easy for an attacker to try
them all.  The official 32\-bit minimum for Blowfish was already far
too short for serious security at the time that Blowfish was designed.
(A machine to crack 56\-bit \s-1DES\s0 keys by brute force in a few days each
was publicly built only five years later.)  Do not base your security
on the secrecy of a short key.
.PP
Using overlong keys has more interesting effects, which depend on internal
features of Blowfish.  When the key exceeds 64 octets (512 bits), varying
key bits past that length results in subkeys which have predictable
relationships.  There is also some possibility of equivalent keys when
the keys exceed 64 octets and differ only in the first 8 octets (64 bits).
These phenomena have not been extensively studied in the open literature,
so it is difficult to judge the degree of cryptographic weakness that
results from them.  It is clear that beyond some length Blowfish keys
do not have as much strength as their length would suggest, and it is
possible that overlong keys have specific weaknesses that render them
weaker than shorter keys.  If choosing a key for security, it is advised
to stay within the official length limit of 56 octets.
.PP
In summary: using Blowfish keys of officially-unsupported lengths
causes security problems.  If you are using Blowfish for security,
and have the choice, use a key of an officially-supported length (and
a standard implementation such as Crypt::Eksblowfish::Blowfish).
Use out-of-range key lengths (and this class) only for compatibility or
cryptanalytic reasons.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.IP "Crypt::Eksblowfish::Uklblowfish\->blocksize" 4
.IX Item "Crypt::Eksblowfish::Uklblowfish->blocksize"
Returns 8, indicating the Blowfish block size of 8 octets.  This method
may be called on either the class or an instance.
.IP "Crypt::Eksblowfish::Uklblowfish\->keysize" 4
.IX Item "Crypt::Eksblowfish::Uklblowfish->keysize"
Returns 0, indicating that the key size is variable.  This situation is
handled specially by \f(CW\*(C`Crypt::CBC\*(C'\fR.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "Crypt::Eksblowfish::Uklblowfish\->new(\s-1KEY\s0)" 4
.IX Item "Crypt::Eksblowfish::Uklblowfish->new(KEY)"
Performs key setup on a new instance of the Blowfish algorithm, returning
the keyed state.  The \s-1KEY\s0 may be any length from 1 octet to 72 octets
inclusive.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$cipher\->blocksize" 4
.el .IP "\f(CW$cipher\fR\->blocksize" 4
.IX Item "$cipher->blocksize"
Returns 8, indicating the Blowfish block size of 8 octets.  This method
may be called on either the class or an instance.
.ie n .IP "$cipher\->encrypt(\s-1PLAINTEXT\s0)" 4
.el .IP "\f(CW$cipher\fR\->encrypt(\s-1PLAINTEXT\s0)" 4
.IX Item "$cipher->encrypt(PLAINTEXT)"
\&\s-1PLAINTEXT\s0 must be exactly eight octets.  The block is encrypted, and
the ciphertext is returned.
.ie n .IP "$cipher\->decrypt(\s-1CIPHERTEXT\s0)" 4
.el .IP "\f(CW$cipher\fR\->decrypt(\s-1CIPHERTEXT\s0)" 4
.IX Item "$cipher->decrypt(CIPHERTEXT)"
\&\s-1CIPHERTEXT\s0 must be exactly eight octets.  The block is decrypted, and
the plaintext is returned.
.ie n .IP "$cipher\->p_array" 4
.el .IP "\f(CW$cipher\fR\->p_array" 4
.IX Item "$cipher->p_array"
.PD 0
.ie n .IP "$cipher\->s_boxes" 4
.el .IP "\f(CW$cipher\fR\->s_boxes" 4
.IX Item "$cipher->s_boxes"
.PD
These methods extract the subkeys from the keyed cipher.
This is not required in ordinary operation.  See the superclass
Crypt::Eksblowfish::Subkeyed for details.
.ie n .IP "$cipher\->is_weak" 4
.el .IP "\f(CW$cipher\fR\->is_weak" 4
.IX Item "$cipher->is_weak"
This method checks whether the cipher has been keyed with a weak key.
It may be desired to avoid using weak keys.  See the superclass
Crypt::Eksblowfish::Subkeyed for details.
.Sp
This method does not detect any cryptographic weaknesses that might result
from the related-key properties and other features of overlong keys.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Crypt::Eksblowfish::Blowfish
.SH "AUTHOR"
.IX Header "AUTHOR"
Eksblowfish guts originally by Solar Designer (solar at openwall.com).
.PP
Modifications and Perl interface by Andrew Main (Zefram)
<zefram@fysh.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011
Andrew Main (Zefram) <zefram@fysh.org>
.PP
The original Eksblowfish code (in the form of \fIcrypt()\fR) from which
this module is derived is in the public domain.  It may be found at
<http://www.openwall.com/crypt/>.
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
