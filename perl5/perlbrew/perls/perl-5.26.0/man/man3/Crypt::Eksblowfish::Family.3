.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Crypt::Eksblowfish::Family 3"
.TH Crypt::Eksblowfish::Family 3 "2018-08-13" "perl v5.26.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::Eksblowfish::Family \- Eksblowfish cipher family
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Crypt::Eksblowfish::Family;
\&
\&        $family = Crypt::Eksblowfish::Family\->new_family(8, $salt);
\&
\&        $cost = $family\->cost;
\&        $salt = $family\->salt;
\&        $block_size = $family\->blocksize;
\&        $key_size = $family\->keysize;
\&        $cipher = $family\->new($key);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of this class represents an Eksblowfish cipher family.
It contains the family parameters (cost and salt), and if combined
with a key it yields an encryption function.  See Crypt::Eksblowfish
for discussion of the Eksblowfish algorithm.
.PP
It is intended that an object of this class can be used in situations
such as the \*(L"\-cipher\*(R" parameter to \f(CW\*(C`Crypt::CBC\*(C'\fR.  Normally that parameter
is the name of a class, such as \*(L"Crypt::Rijndael\*(R", where the class
implements a block cipher algorithm.  The class provides a \f(CW\*(C`new\*(C'\fR
constructor that accepts a key.  In the case of Eksblowfish, the key
alone is not sufficient.  An Eksblowfish family fills the role of block
cipher algorithm.  Therefore a family object is used in place of a class
name, and it is the family object the provides the \f(CW\*(C`new\*(C'\fR constructor.
.SS "Crypt::CBC"
.IX Subsection "Crypt::CBC"
\&\f(CW\*(C`Crypt::CBC\*(C'\fR itself has a problem, with the result that this class can
no longer be used with it in the manner originally intended.
.PP
When this class was originally designed, it worked with \f(CW\*(C`Crypt::CBC\*(C'\fR
as described above: an object of this class would be accepted by
\&\f(CW\*(C`Crypt::CBC\*(C'\fR as a cipher algorithm, and \f(CW\*(C`Crypt::CBC\*(C'\fR would happily
supply it with a key and encrypt using the resulting cipher object.
\&\f(CW\*(C`Crypt::CBC\*(C'\fR didn't realise it was dealing with a family object, however,
and there was some risk that a future version might accidentally squash
the object into a string, which would be no use.  In the course of
discussion about regularising the use of cipher family objects, the
author of \f(CW\*(C`Crypt::CBC\*(C'\fR got hold of the wrong end of the stick, and
ended up changing \f(CW\*(C`Crypt::CBC\*(C'\fR in a way that totally breaks this usage,
rather than putting it on a secure footing.
.PP
The present behaviour of \f(CW\*(C`Crypt::CBC\*(C'\fR is that if an object (rather
than a class name) is supplied as the \*(L"\-cipher\*(R" parameter then it has
a completely different meaning from usual.  In this case, the object
supplied is used as the keyed cipher, rather than as a cipher algorithm
which must be given a key.  This bypasses all of \f(CW\*(C`Crypt::CBC\*(C'\fR's usual
keying logic, which can hash and salt a passphrase to generate the key.
It is arguably a useful feature, but it's a gross abuse of the \*(L"\-cipher\*(R"
parameter and a severe impediment to the use of family-keyed cipher
algorithms.
.PP
This class now provides a workaround.  For the benefit of \f(CW\*(C`Crypt::CBC\*(C'\fR,
and any other crypto plumbing that requires a keyable cipher algorithm
to look like a Perl class (rather than an object), a family object
of this class can in fact be reified as a class of its own.  See the
method \*(L"as_class\*(R".
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "Crypt::Eksblowfish::Family\->new_family(\s-1COST, SALT\s0)" 4
.IX Item "Crypt::Eksblowfish::Family->new_family(COST, SALT)"
Creates and returns an object representing the Eksblowfish cipher
family specified by the parameters.  The \s-1SALT\s0 is a family key, and must
be exactly 16 octets.  \s-1COST\s0 is an integer parameter controlling the
expense of keying: the number of operations in key setup is proportional
to 2^COST.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$family\->cost" 4
.el .IP "\f(CW$family\fR\->cost" 4
.IX Item "$family->cost"
Extracts and returns the cost parameter.
.ie n .IP "$family\->salt" 4
.el .IP "\f(CW$family\fR\->salt" 4
.IX Item "$family->salt"
Extracts and returns the salt parameter.
.ie n .IP "$family\->blocksize" 4
.el .IP "\f(CW$family\fR\->blocksize" 4
.IX Item "$family->blocksize"
Returns 8, indicating the Eksblowfish block size of 8 octets.
.ie n .IP "$family\->keysize" 4
.el .IP "\f(CW$family\fR\->keysize" 4
.IX Item "$family->keysize"
Returns 0, indicating that the key size is variable.  This situation is
handled specially by \f(CW\*(C`Crypt::CBC\*(C'\fR.
.ie n .IP "$family\->new(\s-1KEY\s0)" 4
.el .IP "\f(CW$family\fR\->new(\s-1KEY\s0)" 4
.IX Item "$family->new(KEY)"
Performs key setup on a new instance of the Eksblowfish algorithm,
returning the keyed state.  The \s-1KEY\s0 may be any length from 1 octet to 72
octets inclusive.  The object returned is of class \f(CW\*(C`Crypt::Eksblowfish\*(C'\fR;
see Crypt::Eksblowfish for the encryption and decryption methods.
.Sp
Note that this method is called on a family object, not on the class
\&\f(CW\*(C`Crypt::Eksblowfish::Family\*(C'\fR.
.ie n .IP "$family\->encrypt" 4
.el .IP "\f(CW$family\fR\->encrypt" 4
.IX Item "$family->encrypt"
This method nominally exists, to satisfy \f(CW\*(C`Crypt::CBC\*(C'\fR.  It can't really
be used: it doesn't make any sense.
.ie n .IP "$family\->as_class" 4
.el .IP "\f(CW$family\fR\->as_class" 4
.IX Item "$family->as_class"
Generates and returns (the name of) a Perl class that behaves as a
keyable cipher algorithm identical to this Eksblowfish cipher family.
The same methods that can be called as instance methods on \f(CW$family\fR can
be called as class methods on the generated class.
.Sp
You should prefer to use the family object directly wherever you can.
Aside from being a silly indirection, the classes generated by this
method cannot be garbage-collected.  This method exists only to cater to
\&\f(CW\*(C`Crypt::CBC\*(C'\fR, which requires a keyable cipher algorithm to look like a
Perl class, and won't operate correctly on one that looks like an object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Crypt::CBC,
Crypt::Eksblowfish
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrew Main (Zefram) <zefram@fysh.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011
Andrew Main (Zefram) <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
