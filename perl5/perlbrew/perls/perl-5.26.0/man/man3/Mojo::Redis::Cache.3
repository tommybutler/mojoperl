.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Mojo::Redis::Cache 3"
.TH Mojo::Redis::Cache 3 "2019-04-24" "perl v5.26.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::Redis::Cache \- Simple cache interface using Redis
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::Redis;
\&
\&  my $redis = Mojo::Redis\->new;
\&  my $cache = $redis\->cache;
\&
\&  # Cache and expire the data after 60.7 seconds
\&  $cache\->compute_p("some:key", 60.7, sub {
\&    my $p = Mojo::Promise\->new;
\&    Mojo::IOLoop\->timer(0.1 => sub { $p\->resolve("some data") });
\&    return $p;
\&  })\->then(sub {
\&    my $some_key = shift;
\&  });
\&
\&  # Cache and expire the data after default_expire() seconds
\&  $cache\->compute_p("some:key", sub {
\&    return {some => "data"};
\&  })\->then(sub {
\&    my $some_key = shift;
\&  });
\&
\&  # Call $obj\->get_some_slow_data() and cache the return value
\&  $cache\->memoize_p($obj, "get_some_slow_data")\->then(sub {
\&    my $data = shift;
\&  });
\&
\&  # Call $obj\->get_some_data_by_id({id => 42}) and cache the return value
\&  $cache\->memoize_p($obj, "get_some_data_by_id", [{id => 42}])\->then(sub {
\&    my $data = shift;
\&  });
.Ve
.PP
See <https://github.com/jhthorsen/mojo\-redis/blob/master/examples/cache.pl>
for example Mojolicious application.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::Redis::Cache provides a simple interface for caching data in the
Redis database. There is no \*(L"check if exists\*(R", \*(L"get\*(R" or \*(L"set\*(R" methods in this
class. Instead, both \*(L"compute_p\*(R" and \*(L"memoize_p\*(R" will fetch the value
from Redis, if the given compute function / method has been called once, and
the cached data is not expired.
.PP
If you need to check if the value exists, then you can manually look up the
the key using \*(L"exists\*(R" in Mojo::Redis::Database.
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
.SS "\s-1MOJO_REDIS_CACHE_OFFLINE\s0"
.IX Subsection "MOJO_REDIS_CACHE_OFFLINE"
Set \f(CW\*(C`MOJO_REDIS_CACHE_OFFLINE\*(C'\fR to 1 if you want to use this cache without a
real Redis backend. This can be useful in unit tests.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "connection"
.IX Subsection "connection"
.Vb 2
\&  $conn  = $cache\->connection;
\&  $cache = $cache\->connection(Mojo::Redis::Connection\->new);
.Ve
.PP
Holds a Mojo::Redis::Connection object.
.SS "default_expire"
.IX Subsection "default_expire"
.Vb 2
\&  $num  = $cache\->default_expire;
\&  $cache = $cache\->default_expire(600);
.Ve
.PP
Holds the default expire time for cached data.
.SS "deserialize"
.IX Subsection "deserialize"
.Vb 2
\&  $cb   = $cache\->deserialize;
\&  $cache = $cache\->deserialize(\e&Mojo::JSON::decode_json);
.Ve
.PP
Holds a callback used to deserialize data from Redis.
.SS "namespace"
.IX Subsection "namespace"
.Vb 2
\&  $str  = $cache\->namespace;
\&  $cache = $cache\->namespace("cache:mojo:redis");
.Ve
.PP
Prefix for the cache key.
.SS "redis"
.IX Subsection "redis"
.Vb 2
\&  $conn = $cache\->redis;
\&  $cache = $cache\->redis(Mojo::Redis\->new);
.Ve
.PP
Holds a Mojo::Redis object used to create the connection to talk with Redis.
.SS "refresh"
.IX Subsection "refresh"
.Vb 2
\&  $bool = $cache\->refresh;
\&  $cache = $cache\->refresh(1);
.Ve
.PP
Will force the cache to be computed again if set to a true value.
.SS "serialize"
.IX Subsection "serialize"
.Vb 2
\&  $cb   = $cache\->serialize;
\&  $cache = $cache\->serialize(\e&Mojo::JSON::encode_json);
.Ve
.PP
Holds a callback used to serialize before storing the data in Redis.
.SH "METHODS"
.IX Header "METHODS"
.SS "compute_p"
.IX Subsection "compute_p"
.Vb 3
\&  $promise = $cache\->compute_p($key => $expire => $compute_function);
\&  $promise = $cache\->compute_p($key => $expire => sub { return "data" });
\&  $promise = $cache\->compute_p($key => $expire => sub { return Mojo::Promise\->new });
.Ve
.PP
This method will store the return value from the \f(CW$compute_function\fR the
first time it is called and pass the same value to \*(L"then\*(R" in Mojo::Promise.
\&\f(CW$compute_function\fR will not be called the next time, if the \f(CW$key\fR is
still present in Redis, but instead the cached value will be passed on to
\&\*(L"then\*(R" in Mojo::Promise.
.PP
\&\f(CW$key\fR will be prefixed by \*(L"namespace\*(R" resulting in \*(L"namespace:some\-key\*(R".
.PP
\&\f(CW$expire\fR is the number of seconds before the cache should expire, and will
default to \*(L"default_expire\*(R" unless passed in. The last argument is a
callback used to calculate cached value.
.PP
\&\f(CW$expire\fR can also be a negative number. This will result in serving old cache
in the case where the \f(CW$compute_function\fR fails. An example usecase would be
if you are fetching Twitter updates for your website, but instead of throwing
an exception if Twitter is down, you will serve old data instead. Note that the
fulfilled promise will get two variables passed in:
.PP
.Vb 1
\&  $promise\->then(sub { my ($data, $info) = @_ });
.Ve
.PP
\&\f(CW$info\fR is a hash and can have these keys:
.IP "\(bu" 2
computed
.Sp
Will be true if the \f(CW$compute_function\fR was called successfully and \f(CW$data\fR
is fresh.
.IP "\(bu" 2
expired
.Sp
Will be true if \f(CW$data\fR is expired. If this key is present and false, it will
indicate that the \f(CW$data\fR is within the expiration period. The \f(CW\*(C`expired\*(C'\fR key
can be found together with both \*(L"computed\*(R" and \*(L"error\*(R".
.IP "\(bu" 2
error
.Sp
Will hold a string if the \f(CW$compute_function\fR failed.
.PP
Negative \f(CW$expire\fR is currently \s-1EXPERIMENTAL,\s0 but unlikely to go away.
.SS "memoize_p"
.IX Subsection "memoize_p"
.Vb 2
\&  $promise = $cache\->memoize_p($obj, $method_name, \e@args, $expire);
\&  $promise = $cache\->memoize_p($class, $method_name, \e@args, $expire);
.Ve
.PP
\&\*(L"memoize_p\*(R" behaves the same way as \*(L"compute_p\*(R", but has a convenient
interface for calling methods on an object. One of the benefits is that you
do not have to come up with your own cache key. This method is pretty much
the same as:
.PP
.Vb 5
\&  $promise = $cache\->compute_p(
\&    join(":", $cache\->namespace, "@M", ref($obj), $method_name, serialize(\e@args)),
\&    $expire,
\&    sub { return $obj\->$method_name(@args) }
\&  );
.Ve
.PP
See \*(L"compute_p\*(R" regarding \f(CW$expire\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojo::Redis
