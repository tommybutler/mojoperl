.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Test::Spelling 3"
.TH Test::Spelling 3 "2014-10-07" "perl v5.26.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Spelling \- check for spelling errors in POD files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    use Test::More;
\&    BEGIN {
\&        plan skip_all => "Spelling tests only for authors"
\&            unless \-d \*(Aqinc/.author\*(Aq;
\&    }
\&
\&    use Test::Spelling;
\&    all_pod_files_spelling_ok();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Test::Spelling\*(C'\fR lets you check the spelling of a \s-1POD\s0 file, and report
its results in standard \f(CW\*(C`Test::More\*(C'\fR fashion. This module requires a
spellcheck program such as \fIspell\fR, \fIaspell\fR, \fIispell\fR, or \fIhunspell\fR.
.PP
.Vb 2
\&    use Test::Spelling;
\&    pod_file_spelling_ok(\*(Aqlib/Foo/Bar.pm\*(Aq, \*(AqPOD file spelling OK\*(Aq);
.Ve
.PP
Note that it is a bad idea to run spelling tests during an ordinary \s-1CPAN\s0
distribution install, or in a package that will run in an uncontrolled
environment. There is no way of predicting whether the word list or spellcheck
program used will give the same results. You \fBcan\fR include the test in your
distribution, but be sure to run it only for authors of the module by guarding
it in a \f(CW\*(C`skip_all unless \-d \*(Aqinc/.author\*(Aq\*(C'\fR clause, or by putting the test in
your distribution's \fIxt/\fR directory. Anyway, people installing your module
really do not need to run such tests, as it is unlikely that the documentation
will acquire typos while in transit. :\-)
.PP
You can add your own stop words, which are words that should be ignored by the
spell check, like so:
.PP
.Vb 1
\&    add_stopwords(qw(asdf thiswordiscorrect));
.Ve
.PP
Adding stop words in this fashion affects all files checked for the remainder of
the test script. See Pod::Spell (which this module is built upon) for a
variety of ways to add per-file stop words to each .pm file.
.PP
If you have a lot of stop words, it's useful to put them in your test file's
\&\f(CW\*(C`DATA\*(C'\fR section like so:
.PP
.Vb 3
\&    use Test::Spelling;
\&    add_stopwords(<DATA>);
\&    all_pod_files_spelling_ok();
\&
\&    _\|_END_\|_
\&    folksonomy
\&    Jifty
\&    Zakirov
.Ve
.PP
To maintain backwards compatibility, comment markers and some whitespace are
ignored. In the near future, the preprocessing we do on the arguments to
add_stopwords will be changed and documented properly.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "all_pod_files_spelling_ok( [@files/@directories] )"
.IX Subsection "all_pod_files_spelling_ok( [@files/@directories] )"
Checks all the files for \s-1POD\s0 spelling. It gathers \fIall_pod_files()\fR on each
file/directory, and declares a \*(L"plan\*(R" in Test::More for you (one test for each
file), so you must not call \f(CW\*(C`plan\*(C'\fR yourself.
.PP
If \f(CW@files\fR is empty, the function finds all \s-1POD\s0 files in the \fIblib\fR
directory if it exists, or the \fIlib\fR directory if it does not. A \s-1POD\s0 file is
one that ends with \fI.pod\fR, \fI.pl\fR, \fI.plx\fR, or \fI.pm\fR; or any file where the
first line looks like a perl shebang line.
.PP
If there is no working spellchecker (determined by
\&\*(L"has_working_spellchecker\*(R"), this test will issue a \*(L"skip all\*(R" directive.
.PP
If you're testing a distribution, just create a \fIt/pod\-spell.t\fR with the code
in the \*(L"\s-1SYNOPSIS\*(R"\s0.
.PP
Returns true if every \s-1POD\s0 file has correct spelling, or false if any of them fail.
This function will show any spelling errors as diagnostics.
.ie n .SS "pod_file_spelling_ok( $filename[, $testname ] )"
.el .SS "pod_file_spelling_ok( \f(CW$filename\fP[, \f(CW$testname\fP ] )"
.IX Subsection "pod_file_spelling_ok( $filename[, $testname ] )"
\&\f(CW\*(C`pod_file_spelling_ok\*(C'\fR will test that the given \s-1POD\s0 file has no spelling
errors.
.PP
When it fails, \f(CW\*(C`pod_file_spelling_ok\*(C'\fR will show any spelling errors as
diagnostics.
.PP
The optional second argument is the name of the test.  If it is
omitted, \f(CW\*(C`pod_file_spelling_ok\*(C'\fR chooses a default test name "\s-1POD\s0
spelling for \f(CW$filename\fR".
.SS "all_pod_files( [@dirs] )"
.IX Subsection "all_pod_files( [@dirs] )"
Returns a list of all the Perl files in each directory and its subdirectories,
recursively. If no directories are passed, it defaults to \fIblib\fR if \fIblib\fR
exists, or else \fIlib\fR if not. Skips any files in \fI\s-1CVS\s0\fR or \fI.svn\fR directories.
.PP
A Perl file is:
.IP "\(bu" 4
Any file that ends in \fI.PL\fR, \fI.pl\fR, \fI.plx\fR, \fI.pm\fR, \fI.pod\fR or \fI.t\fR.
.IP "\(bu" 4
Any file that has a first line with a shebang and \*(L"perl\*(R" on it.
.PP
Furthermore, files for which the filter set by \*(L"set_pod_file_filter\*(R" return
false are skipped. By default, this filter passes everything through.
.PP
The order of the files returned is machine-dependent.  If you want them
sorted, you'll have to sort them yourself.
.SS "add_stopwords(@words)"
.IX Subsection "add_stopwords(@words)"
Add words that should be skipped by the spellcheck. Note that Pod::Spell
already skips words believed to be code, such as everything in verbatim
(indented) blocks and code marked up with \f(CW\*(C`\f(CW\*(C`...\*(C'\f(CW\*(C'\fR, as well as some common
Perl jargon.
.SS "has_working_spellchecker"
.IX Subsection "has_working_spellchecker"
\&\f(CW\*(C`has_working_spellchecker\*(C'\fR will return \f(CW\*(C`undef\*(C'\fR if there is no working
spellchecker, or a true value (the spellchecker command itself) if there is.
The module performs a dry-run to determine whether any of the spellcheckers it
can will use work on the current system. You can use this to skip tests if
there is no spellchecker. Note that \*(L"all_pod_files_spelling_ok\*(R" will do this
for you.
.SS "set_spell_cmd($command)"
.IX Subsection "set_spell_cmd($command)"
If you want to force this module to use a particular spellchecker, then you can
specify which one with \f(CW\*(C`set_spell_cmd\*(C'\fR. This is useful to ensure a more
consistent lexicon between developers, or if you have an unusual environment.
Any command that takes text from standard input and prints a list of misspelled
words, one per line, to standard output will do.
.SS "set_pod_file_filter($code)"
.IX Subsection "set_pod_file_filter($code)"
If your project has \s-1POD\s0 documents written in languages other than English, then
obviously you don't want to be running a spellchecker on every Perl file.
\&\f(CW\*(C`set_pod_file_filter\*(C'\fR lets you filter out files returned from
\&\*(L"all_pod_files\*(R" (and hence, the documents tested by
\&\*(L"all_pod_files_spelling_ok\*(R").
.PP
.Vb 5
\&    set_pod_file_filter(sub {
\&        my $filename = shift;
\&        return 0 if $filename =~ /_ja.pod$/; # skip Japanese translations
\&        return 1;
\&    });
.Ve
.SS "set_pod_parser($object)"
.IX Subsection "set_pod_parser($object)"
By default Pod::Spell is used to generate text suitable for spellchecking
from the input \s-1POD.\s0  If you want to use a different parser, perhaps a
customized subclass of Pod::Spell, call \f(CW\*(C`set_pod_parser\*(C'\fR with an object
that is-a Pod::Parser.  Be sure to create a fresh parser object for
each file (don't use this with \f(CW\*(C`all_pod_files_spelling_ok\*(C'\fR).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Spell
.SH "ORIGINAL AUTHOR"
.IX Header "ORIGINAL AUTHOR"
Ivan Tubert-Brohman \f(CW\*(C`<itub@cpan.org>\*(C'\fR
.PP
Heavily based on Test::Pod by Andy Lester and brian d foy.
.SH "MAINTAINER"
.IX Header "MAINTAINER"
Shawn M Moore \f(CW\*(C`<code@sartak.org>\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2005, Ivan Tubert-Brohman, All Rights Reserved.
.PP
You may use, modify, and distribute this package under the
same terms as Perl itself.
