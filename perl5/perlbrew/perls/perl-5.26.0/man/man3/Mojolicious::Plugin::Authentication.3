.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Mojolicious::Plugin::Authentication 3"
.TH Mojolicious::Plugin::Authentication 3 "2018-04-21" "perl v5.26.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojolicious::Plugin::Authentication \- A plugin to make authentication a bit easier
.SH "VERSION"
.IX Header "VERSION"
version 1.33
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mojolicious::Plugin::Authentication;
\&
\&    $self\->plugin(\*(Aqauthentication\*(Aq => {
\&        autoload_user   => 1,
\&        session_key     => \*(Aqwickedapp\*(Aq,
\&        load_user       => sub { ... },
\&        validate_user   => sub { ... },
\&        current_user_fn => \*(Aquser\*(Aq, # compatibility with old code
\&    });
\&
\&    my $authenticated = $self\->authenticate(
\&        \*(Aqusername\*(Aq, \*(Aqpassword\*(Aq,
\&        { optional => \*(Aqextra data stuff\*(Aq },
\&    );
\&
\&    if ($authenticated) {
\&        ...
\&    }
.Ve
.SH "METHODS"
.IX Header "METHODS"
Like other Mojolicious plugins, loading this plugin will import some function
helpers into the namespace of your application. This will not normally cause
any trouble, but be aware that if you define methods with the same names as
those below, you'll likely run into unexpected results.
.ie n .SS "authenticate($username, $password, $extra_data_hashref)"
.el .SS "authenticate($username, \f(CW$password\fP, \f(CW$extra_data_hashref\fP)"
.IX Subsection "authenticate($username, $password, $extra_data_hashref)"
Authenticate will use the supplied \f(CW\*(C`load_user\*(C'\fR and \f(CW\*(C`validate_user\*(C'\fR
subroutine refs to see whether a user exists with the given username and
password, and will set up the session accordingly. Returns true when the user
has been successfully authenticated, false otherwise. You can pass additional
data along in the \f(CW\*(C`extra_data\*(C'\fR hashref, it will be passed to your
\&\f(CW\*(C`validate_user\*(C'\fR subroutine as-is. If the extra data hash contains a key
\&\f(CW\*(C`auto_validate\*(C'\fR, the value of that key will be used as the \s-1UID,\s0 and
authenticate will not call your \f(CW\*(C`validate_user\*(C'\fR callback; this can be used
when working with OAuth tokens or other authentication mechanisms that do not
use a local username and password form.
.SS "is_user_authenticated"
.IX Subsection "is_user_authenticated"
Returns true if \fIcurrent_user()\fR returns some valid object, false otherwise.
.SS "current_user"
.IX Subsection "current_user"
Returns the user object as it was returned from the supplied \f(CW\*(C`load_user\*(C'\fR
subroutine ref.
.PP
You can change the current user by passing it in, but be careful: This
bypasses the authentication. This is useful if you have multiple ways to
authenticate users and want to re-use authorization checks that use
\&\f(CW\*(C`current_user\*(C'\fR.
.SS "reload_user"
.IX Subsection "reload_user"
Flushes the current user object and then returns \fIuser()\fR.
.SS "signature_exists"
.IX Subsection "signature_exists"
Returns true if uid signature exist on the client side (in cookies), false
otherwise.
.PP
Warning: non-secure check! Use this method only for a \*(L"fast & dirty\*(R" lookup
to see if the client has the proper cookies. May be helpful in some cases
(for example \- in counting \f(CW\*(C`guest\*(C'\fR/\f(CW\*(C`logged users\*(C'\fR or for additional
non-confidential information for \f(CW\*(C`logged users\*(C'\fR but not for \f(CW\*(C`guest\*(C'\fR).
.SS "logout"
.IX Subsection "logout"
Removes the session data for authentication, and effectively logs a user out.
Returns a true value, to allow for chaining.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
The following options can be set for the plugin:
.IP "load_user (\s-1REQUIRED\s0)" 4
.IX Item "load_user (REQUIRED)"
A coderef for user loading (see \*(L"\s-1USER LOADING\*(R"\s0)
.IP "validate_user (\s-1REQUIRED\s0)" 4
.IX Item "validate_user (REQUIRED)"
A coderef for user validation (see \*(L"\s-1USER VALIDATION\*(R"\s0)
.IP "session_key (optional)" 4
.IX Item "session_key (optional)"
The name of the session key
.IP "autoload_user (optional)" 4
.IX Item "autoload_user (optional)"
Turn on/off automatic loading of user data \- user data can be loaded only if
it be used. May reduce site latency in some cases.
.IP "current_user_fn (optional)" 4
.IX Item "current_user_fn (optional)"
Set the name for the \f(CW\*(C`current_user()\*(C'\fR helper function
.IP "fail_render (optional)" 4
.IX Item "fail_render (optional)"
Specify what is to be rendered when the authenticated condition is not met.
.Sp
Set to a coderef which will be called with the following signature:
.Sp
.Vb 5
\&    sub {
\&        my ($routes, $controller, $captures, $required) = @_;
\&        ...
\&        return $hashref;
\&    }
.Ve
.Sp
The return value of the subroutine will be ignored if it evaluates to false.
If it returns a hash reference, it will be dereferenced and passed as-is
to the controller's \f(CW\*(C`render\*(C'\fR function. If you return anything else, you are
going to have a bad time.
.Sp
If set directly to a hash reference, that will be passed to \f(CW\*(C`render\*(C'\fR instead.
.PP
In order to set the session expiry time, use the following in your startup
routine:
.PP
.Vb 3
\&    $app\->plugin(\*(Aqauthentication\*(Aq, { ... });
\&    $app\->sessions\->default_expiration(86400); # set expiry to 1 day
\&    $app\->sessions\->default_expiration(3600); # set expiry to 1 hour
.Ve
.SH "USER LOADING"
.IX Header "USER LOADING"
The coderef you pass to the load_user configuration key has the following
signature:
.PP
.Vb 5
\&    sub {
\&        my ($app, $uid) = @_;
\&        ...
\&        return $user;
\&    }
.Ve
.PP
The uid is the value that was originally returned from the \f(CW\*(C`validate_user\*(C'\fR
coderef. You must return either a user object (it can be a hashref, arrayref,
or a blessed object) or undef.
.SH "USER VALIDATION"
.IX Header "USER VALIDATION"
User validation is what happens when we need to authenticate someone. The
coderef you pass to the \f(CW\*(C`validate_user\*(C'\fR configuration key has the following
signature:
.PP
.Vb 5
\&    sub {
\&        my ($c, $username, $password, $extradata) = @_;
\&        ...
\&        return $uid;
\&    }
.Ve
.PP
You must return either a user id or undef. The user id can be numerical or a
string. Do not return hashrefs, arrayrefs or objects, since the behaviour of
this plugin could get a little bit on the odd side of weird if you do that.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
For a code example using this, see the \fIt/01\-functional.t\fR and
\&\fIt/02\-functional_lazy.t\fR tests, it uses Mojolicious::Lite and this plugin.
.SH "ROUTING VIA CONDITION"
.IX Header "ROUTING VIA CONDITION"
This plugin also exports a routing condition you can use in order to limit
access to certain documents to only authenticated users.
.PP
.Vb 1
\&    $r\->route(\*(Aq/foo\*(Aq)\->over(authenticated => 1)\->to(\*(Aqmycontroller#foo\*(Aq);
\&
\&    my $authenticated_only = $r\->route(\*(Aq/members\*(Aq)
\&        \->over(authenticated => 1)
\&        \->to(\*(Aqmembers#index\*(Aq);
\&
\&    $authenticated_only\->route(\*(Aqonline\*(Aq)\->to(\*(Aqmembers#online\*(Aq);
.Ve
.PP
If someone is not authenticated, these routes will not be considered by the
dispatcher and unless you have set up a catch-all route, a 404 Not Found will
be generated instead.
.PP
And another condition for fast and unsecured checking for users, having a
signature (without validating it). This method just checks client cookies for
uid data existing.
.PP
.Vb 1
\&    $r\->route(\*(Aq/foo\*(Aq)\->over(signed => 1)\->to(\*(Aqmycontroller#foo\*(Aq);
.Ve
.PP
This behavior is similar to the \*(L"authenticated\*(R" condition.
.SH "ROUTING VIA CALLBACK"
.IX Header "ROUTING VIA CALLBACK"
If you want to be able to send people to a login page, you will have to use
the following:
.PP
.Vb 2
\&    my $members_only = $r\->route(\*(Aq/members\*(Aq)\->to(cb => sub {
\&        my $self = shift;
\&
\&        $self\->redirect_to(\*(Aq/login\*(Aq) and return 0
\&            unless($self\->is_user_authenticated);
\&
\&        return 1;
\&    });
\&
\&    $members_only\->route(\*(Aqonline\*(Aq)\->to(\*(Aqmembers#online\*(Aq);
.Ve
.PP
Lazy and unsecured methods:
.PP
.Vb 2
\&    my $members_only = $r\->route(\*(Aq/unimportant\*(Aq)\->to(cb => sub {
\&        my $self = shift;
\&
\&        $self\->redirect_to(\*(Aq/login\*(Aq) and return 0
\&            unless($self\->signature_exists);
\&
\&        return 1;
\&    });
\&
\&    $members_only\->route(\*(Aqpages\*(Aq)\->to(\*(Aqunimportant#pages\*(Aq);
.Ve
.SH "ROUTING VIA BRIDGE"
.IX Header "ROUTING VIA BRIDGE"
If you want to be able to send people to a login page, you will have to use
the following:
.PP
.Vb 3
\&    my $auth_bridge = $r\->under(\*(Aq/members\*(Aq)\->to(\*(Aqauth#check\*(Aq);
\&    # only visible to logged in users
\&    $auth_bridge\->route(\*(Aq/list\*(Aq)\->to(\*(Aqmembers#list\*(Aq);
.Ve
.PP
And in your Auth controller you would put:
.PP
.Vb 2
\&    sub check {
\&        my $self = shift;
\&
\&        $self\->redirect_to(\*(Aq/login\*(Aq) and return 0
\&            unless($self\->is_user_authenticated);
\&
\&        return 1;
\&    };
.Ve
.PP
Lazy and unsecured methods:
.PP
.Vb 2
\&    sub check {
\&        my $self = shift;
\&
\&        $self\->redirect_to(\*(Aq/login\*(Aq) and return 0
\&            unless($self\->signature_exists);
\&
\&        return 1;
\&    };
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Mojolicious::Sessions" 4
.IX Item "Mojolicious::Sessions"
.PD 0
.IP "Mojocast 3: Authentication <http://mojocasts.com/e3#>" 4
.IX Item "Mojocast 3: Authentication <http://mojocasts.com/e3#>"
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
.ie n .IP "Ben van Staveren, ""<madcat at cpan.org>""" 4
.el .IP "Ben van Staveren, \f(CW<madcat at cpan.org>\fR" 4
.IX Item "Ben van Staveren, <madcat at cpan.org>"
.PD 0
.ie n .IP "José Joaquín Atria, ""<jjatria@cpan.org>""" 4
.el .IP "José Joaquín Atria, \f(CW<jjatria@cpan.org>\fR" 4
.IX Item "José Joaquín Atria, <jjatria@cpan.org>"
.PD
.SH "BUGS / CONTRIBUTING"
.IX Header "BUGS / CONTRIBUTING"
Please report any bugs or feature requests through the web interface at
<https://github.com/benvanstaveren/mojolicious\-plugin\-authentication/issues>.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Mojolicious::Plugin::Authentication
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Mojolicious\-Plugin\-Authentication>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/Mojolicious\-Plugin\-Authentication>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Mojolicious\-Plugin\-Authentication/>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Andrew Parker
    \-   For pointing out some bugs that crept in; a silent reminder not to
        code while sleepy
.PP
Mirko Westermeier (memowe)
    \-   For doing some (much needed) code cleanup
.PP
Terrence Brannon (metaperl)
    \-   Documentation patches
.PP
Karpich Dmitry (meettya)
    \-   \f(CW\*(C`lazy_mode\*(C'\fR and \f(CW\*(C`signature_exists\*(C'\fR functionality, including a test
        and documentation
.PP
Ivo Welch
    \-   For donating his first ever Mojolicious application that shows an
        example of how to use this module
.PP
Ed Wildgoose (ewildgoose)
    \-   Adding the \f(CW\*(C`current_user()\*(C'\fR functionality, as well as some method
        renaming to make things a bit more sane.
.PP
Colin Cyr (SailingYYC)
    \-   For reporting an issue with routing conditions; I really should not
        code while sleepy, brainfarts imminent!
.PP
Carlos Ramos (carragom)
    \-   For fixing the bug that'd consider an uid of 0 or \*(L"0\*(R" to be a problem
.PP
Doug Bell (preaction)
    \-   For improving the Travis \s-1CI\s0 integration and enabling arguments for
        current_user
.PP
Roman F (moltar)
    \-   For fixing some pesky typos in sample code
.PP
Hernan Lopes (hernan604)
    \-   For updating some deprecated method names in the documentation
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2011\-2017 Ben van Staveren.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the \s-1GNU\s0 General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See http://dev.perl.org/licenses/ for more information.
