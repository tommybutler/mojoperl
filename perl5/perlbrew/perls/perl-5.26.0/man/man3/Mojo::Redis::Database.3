.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Mojo::Redis::Database 3"
.TH Mojo::Redis::Database 3 "2019-05-04" "perl v5.26.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::Redis::Database \- Execute basic redis commands
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::Redis;
\&
\&  my $redis = Mojo::Redis\->new;
\&  my $db    = $redis\->db;
\&
\&  # Blocking
\&  say "foo=" .$db\->get("foo");
\&
\&  # Non\-blocking
\&  $db\->get(foo => sub { my ($db, $res) = @_; say "foo=$res" });
\&
\&  # Promises
\&  $db\->get_p("foo")\->then(sub { my ($res) = @_; say "foo=$res" });
.Ve
.PP
See <https://github.com/jhthorsen/mojo\-redis/blob/master/examples/twitter.pl>
for example Mojolicious application.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::Redis::Database has methods for sending and receiving structured
data to the Redis server.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "redis"
.IX Subsection "redis"
.Vb 2
\&  $conn = $db\->redis;
\&  $db = $db\->redis(Mojo::Redis\->new);
.Ve
.PP
Holds a Mojo::Redis object used to create the connections to talk with Redis.
.SH "METHODS"
.IX Header "METHODS"
.SS "append"
.IX Subsection "append"
.Vb 3
\&  $int     = $db\->append($key, $value);
\&  $db      = $db\->append($key, $value, sub { my ($db, $err, $int) = @_ });
\&  $promise = $db\->append_p($key, $value);
.Ve
.PP
Append a value to a key.
.PP
See <https://redis.io/commands/append> for more information.
.SS "bgrewriteaof"
.IX Subsection "bgrewriteaof"
.Vb 3
\&  $ok      = $db\->bgrewriteaof;
\&  $db      = $db\->bgrewriteaof(sub { my ($db, $err, $ok) = @_ });
\&  $promise = $db\->bgrewriteaof_p;
.Ve
.PP
Asynchronously rewrite the append-only file.
.PP
See <https://redis.io/commands/bgrewriteaof> for more information.
.SS "bgsave"
.IX Subsection "bgsave"
.Vb 3
\&  $ok      = $db\->bgsave;
\&  $db      = $db\->bgsave(sub { my ($db, $err, $ok) = @_ });
\&  $promise = $db\->bgsave_p;
.Ve
.PP
Asynchronously save the dataset to disk.
.PP
See <https://redis.io/commands/bgsave> for more information.
.SS "bitcount"
.IX Subsection "bitcount"
.Vb 3
\&  $int     = $db\->bitcount($key, [start end]);
\&  $db      = $db\->bitcount($key, [start end], sub { my ($db, $err, $int) = @_ });
\&  $promise = $db\->bitcount_p($key, [start end]);
.Ve
.PP
Count set bits in a string.
.PP
See <https://redis.io/commands/bitcount> for more information.
.SS "bitfield"
.IX Subsection "bitfield"
.Vb 3
\&  $res     = $db\->bitfield($key, [GET type offset], [SET type offset value], [INCRBY type offset increment], [OVERFLOW WRAP|SAT|FAIL]);
\&  $db      = $db\->bitfield($key, [GET type offset], [SET type offset value], [INCRBY type offset increment], [OVERFLOW WRAP|SAT|FAIL], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->bitfield_p($key, [GET type offset], [SET type offset value], [INCRBY typeoffset increment], [OVERFLOW WRAP|SAT|FAIL]);
.Ve
.PP
Perform arbitrary bitfield integer operations on strings.
.PP
See <https://redis.io/commands/bitfield> for more information.
.SS "bitop"
.IX Subsection "bitop"
.Vb 3
\&  $int     = $db\->bitop($operation, $destkey, $key [key ...]);
\&  $db      = $db\->bitop($operation, $destkey, $key [key ...], sub { my ($db, $err, $int) = @_ });
\&  $promise = $db\->bitop_p($operation, $destkey, $key [key ...]);
.Ve
.PP
Perform bitwise operations between strings.
.PP
See <https://redis.io/commands/bitop> for more information.
.SS "bitpos"
.IX Subsection "bitpos"
.Vb 3
\&  $int     = $db\->bitpos($key, $bit, [start], [end]);
\&  $db      = $db\->bitpos($key, $bit, [start], [end], sub { my ($db, $err, $int) = @_ });
\&  $promise = $db\->bitpos_p($key, $bit, [start], [end]);
.Ve
.PP
Find first bit set or clear in a string.
.PP
See <https://redis.io/commands/bitpos> for more information.
.SS "blpop"
.IX Subsection "blpop"
.Vb 2
\&  $db      = $db\->blpop($key [key ...], $timeout, sub { my ($db, $val, $key) = @_ });
\&  $promise = $db\->blpop_p($key [key ...], $timeout);
.Ve
.PP
Remove and get the first element in a list, or block until one is available.
.PP
See <https://redis.io/commands/blpop> for more information.
.SS "brpop"
.IX Subsection "brpop"
.Vb 2
\&  $db      = $db\->brpop($key [key ...], $timeout, sub { my ($db, $val, $key) = @_ });
\&  $promise = $db\->brpop_p($key [key ...], $timeout);
.Ve
.PP
Remove and get the last element in a list, or block until one is available.
.PP
See <https://redis.io/commands/brpop> for more information.
.SS "brpoplpush"
.IX Subsection "brpoplpush"
.Vb 2
\&  $db      = $db\->brpoplpush($source, $destination, $timeout, sub { my ($db, $err, $array_ref) = @_ });
\&  $promise = $db\->brpoplpush_p($source, $destination, $timeout);
.Ve
.PP
Pop a value from a list, push it to another list and return it; or block until one is available.
.PP
See <https://redis.io/commands/brpoplpush> for more information.
.SS "bzpopmax"
.IX Subsection "bzpopmax"
.Vb 2
\&  $db      = $db\->bzpopmax($key [key ...], $timeout, sub { my ($db, $err, $array_ref) = @_ });
\&  $promise = $db\->bzpopmax_p($key [key ...], $timeout);
.Ve
.PP
Remove and return the member with the highest score from one or more sorted sets, or block until one is available.
.PP
See <https://redis.io/commands/bzpopmax> for more information.
.SS "bzpopmin"
.IX Subsection "bzpopmin"
.Vb 2
\&  $db      = $db\->bzpopmin($key [key ...], $timeout, sub { my ($db, $err, $array_ref) = @_ });
\&  $promise = $db\->bzpopmin_p($key [key ...], $timeout);
.Ve
.PP
Remove and return the member with the lowest score from one or more sorted sets, or block until one is available.
.PP
See <https://redis.io/commands/bzpopmin> for more information.
.SS "call"
.IX Subsection "call"
.Vb 2
\&  $res = $db\->call($command => @args);
\&  $db  = $db\->call($command => @args, sub { my ($db, $err, $res) = @_; });
.Ve
.PP
Same as \*(L"call_p\*(R", but either blocks or passes the result into a callback.
.SS "call_p"
.IX Subsection "call_p"
.Vb 2
\&  $promise = $db\->call_p($command => @args);
\&  $promise = $db\->call_p(GET => "some:key");
.Ve
.PP
Used to send a custom command to the Redis server.
.SS "client"
.IX Subsection "client"
.Vb 3
\&  $res     = $db\->client(@args);
\&  $db      = $db\->client(@args, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->client_p(@args);
.Ve
.PP
Run a \*(L"\s-1CLIENT\*(R"\s0 command on the server. \f(CW@args\fR can be:
.IP "\(bu" 2
\&\s-1KILL\s0 [ip:port] [\s-1ID\s0 client\-id] [\s-1TYPE\s0 normal|master|slave|pubsub] [\s-1ADDR\s0 ip:port] [\s-1SKIPME\s0 yes/no]
.IP "\(bu" 2
\&\s-1LIST\s0
.IP "\(bu" 2
\&\s-1GETNAME\s0
.IP "\(bu" 2
\&\s-1PAUSE\s0 timeout
.IP "\(bu" 2
\&\s-1REPLY\s0 [ON|OFF|SKIP]
.IP "\(bu" 2
\&\s-1SETNAME\s0 connection-name
.PP
See <https://redis.io/commands#server> for more information.
.SS "connection"
.IX Subsection "connection"
.Vb 2
\&  $non_blocking_connection = $db\->connection(0);
\&  $blocking_connection     = $db\->connection(1);
.Ve
.PP
Returns a Mojo::Redis::Connection object. The default is to return a
connection suitable for non-blocking methods, but passing in a true value will
return the connection used for blocking methods.
.PP
.Vb 2
\&  # Blocking
\&  my $res = $db\->get("some:key");
\&
\&  # Non\-blocking
\&  $db\->get_p("some:key");
\&  $db\->get("some:key", sub { ... });
.Ve
.SS "cluster"
.IX Subsection "cluster"
.Vb 3
\&  $res     = $db\->cluster(@args);
\&  $db      = $db\->cluster(@args, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->cluster_p(@args);
.Ve
.PP
Used to execute cluster commands.
.PP
See <https://redis.io/commands#cluster> for more information.
.SS "command"
.IX Subsection "command"
.Vb 3
\&  $array_ref = $db\->command(@args);
\&  $db        = $db\->command(@args, sub { my ($db, $err, $array_ref) = @_ });
\&  $promise   = $db\->command_p(@args);
.Ve
.PP
Get array of Redis command details.
.IP "\(bu" 2
empty list
.IP "\(bu" 2
\&\s-1COUNT\s0
.IP "\(bu" 2
\&\s-1GETKEYS\s0
.IP "\(bu" 2
\&\s-1INFO\s0 command-name [command\-name]
.PP
See <https://redis.io/commands/command> for more information.
.SS "dbsize"
.IX Subsection "dbsize"
.Vb 3
\&  $int     = $db\->dbsize;
\&  $db      = $db\->dbsize(sub { my ($db, $err, $int) = @_ });
\&  $promise = $db\->dbsize_p;
.Ve
.PP
Return the number of keys in the selected database.
.PP
See <https://redis.io/commands/dbsize> for more information.
.SS "decr"
.IX Subsection "decr"
.Vb 3
\&  $num     = $db\->decr($key);
\&  $db      = $db\->decr($key, sub { my ($db, $err, $num) = @_ });
\&  $promise = $db\->decr_p($key);
.Ve
.PP
Decrement the integer value of a key by one.
.PP
See <https://redis.io/commands/decr> for more information.
.SS "decrby"
.IX Subsection "decrby"
.Vb 3
\&  $num     = $db\->decrby($key, $decrement);
\&  $db      = $db\->decrby($key, $decrement, sub { my ($db, $err, $num) = @_ });
\&  $promise = $db\->decrby_p($key, $decrement);
.Ve
.PP
Decrement the integer value of a key by the given number.
.PP
See <https://redis.io/commands/decrby> for more information.
.SS "del"
.IX Subsection "del"
.Vb 3
\&  $ok      = $db\->del($key [key ...]);
\&  $db      = $db\->del($key [key ...], sub { my ($db, $err, $ok) = @_ });
\&  $promise = $db\->del_p($key [key ...]);
.Ve
.PP
Delete a key.
.PP
See <https://redis.io/commands/del> for more information.
.SS "discard"
.IX Subsection "discard"
See \*(L"discard_p\*(R".
.SS "discard_p"
.IX Subsection "discard_p"
.Vb 3
\&  $ok      = $db\->discard;
\&  $db      = $db\->discard(sub { my ($db, $err, $ok) = @_ });
\&  $promise = $db\->discard_p;
.Ve
.PP
Discard all commands issued after \s-1MULTI.\s0
.PP
See <https://redis.io/commands/discard> for more information.
.SS "dump"
.IX Subsection "dump"
.Vb 3
\&  $ok      = $db\->dump($key);
\&  $db      = $db\->dump($key, sub { my ($db, $err, $ok) = @_ });
\&  $promise = $db\->dump_p($key);
.Ve
.PP
Return a serialized version of the value stored at the specified key.
.PP
See <https://redis.io/commands/dump> for more information.
.SS "echo"
.IX Subsection "echo"
.Vb 3
\&  $res     = $db\->echo($message);
\&  $db      = $db\->echo($message, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->echo_p($message);
.Ve
.PP
Echo the given string.
.PP
See <https://redis.io/commands/echo> for more information.
.SS "eval"
.IX Subsection "eval"
.Vb 3
\&  $res     = $db\->eval($script, $numkeys, $key [key ...], $arg [arg ...]);
\&  $db      = $db\->eval($script, $numkeys, $key [key ...], $arg [arg ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->eval_p($script, $numkeys, $key [key ...], $arg [arg ...]);
.Ve
.PP
Execute a Lua script server side.
.PP
See <https://redis.io/commands/eval> for more information.
.SS "evalsha"
.IX Subsection "evalsha"
.Vb 3
\&  $res     = $db\->evalsha($sha1, $numkeys, $key [key ...], $arg [arg ...]);
\&  $db      = $db\->evalsha($sha1, $numkeys, $key [key ...], $arg [arg ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->evalsha_p($sha1, $numkeys, $key [key ...], $arg [arg ...]);
.Ve
.PP
Execute a Lua script server side.
.PP
See <https://redis.io/commands/evalsha> for more information.
.SS "exec"
.IX Subsection "exec"
See \*(L"exec_p\*(R".
.SS "exec_p"
.IX Subsection "exec_p"
.Vb 3
\&  $array_ref = $db\->exec;
\&  $db        = $db\->exec(sub { my ($db, $err, $array_ref) = @_ });
\&  $promise   = $db\->exec_p;
.Ve
.PP
Execute all commands issued after \*(L"multi\*(R".
.PP
See <https://redis.io/commands/exec> for more information.
.SS "exists"
.IX Subsection "exists"
.Vb 3
\&  $int     = $db\->exists($key [key ...]);
\&  $db      = $db\->exists($key [key ...], sub { my ($db, $err, $int) = @_ });
\&  $promise = $db\->exists_p($key [key ...]);
.Ve
.PP
Determine if a key exists.
.PP
See <https://redis.io/commands/exists> for more information.
.SS "expire"
.IX Subsection "expire"
.Vb 3
\&  $int     = $db\->expire($key, $seconds);
\&  $db      = $db\->expire($key, $seconds, sub { my ($db, $err, $int) = @_ });
\&  $promise = $db\->expire_p($key, $seconds);
.Ve
.PP
Set a key's time to live in seconds.
.PP
See <https://redis.io/commands/expire> for more information.
.SS "expireat"
.IX Subsection "expireat"
.Vb 3
\&  $int     = $db\->expireat($key, $timestamp);
\&  $db      = $db\->expireat($key, $timestamp, sub { my ($db, $err, $int) = @_ });
\&  $promise = $db\->expireat_p($key, $timestamp);
.Ve
.PP
Set the expiration for a key as a \s-1UNIX\s0 timestamp.
.PP
See <https://redis.io/commands/expireat> for more information.
.SS "flushall"
.IX Subsection "flushall"
.Vb 3
\&  $str     = $db\->flushall([ASYNC]);
\&  $db      = $db\->flushall([ASYNC], sub { my ($db, $err, $str) = @_ });
\&  $promise = $db\->flushall_p([ASYNC]);
.Ve
.PP
Remove all keys from all databases.
.PP
See <https://redis.io/commands/flushall> for more information.
.SS "flushdb"
.IX Subsection "flushdb"
.Vb 3
\&  $str     = $db\->flushdb([ASYNC]);
\&  $db      = $db\->flushdb([ASYNC], sub { my ($db, $err, $str) = @_ });
\&  $promise = $db\->flushdb_p([ASYNC]);
.Ve
.PP
Remove all keys from the current database.
.PP
See <https://redis.io/commands/flushdb> for more information.
.SS "geoadd"
.IX Subsection "geoadd"
.Vb 3
\&  $res     = $db\->geoadd($key, $longitude latitude member [longitude latitude member ...]);
\&  $db      = $db\->geoadd($key, $longitude latitude member [longitude latitude member ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->geoadd_p($key, $longitude latitude member [longitude latitude member ...]);
.Ve
.PP
Add one or more geospatial items in the geospatial index represented using a sorted set.
.PP
See <https://redis.io/commands/geoadd> for more information.
.SS "geodist"
.IX Subsection "geodist"
.Vb 3
\&  $res     = $db\->geodist($key, $member1, $member2, [unit]);
\&  $db      = $db\->geodist($key, $member1, $member2, [unit], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->geodist_p($key, $member1, $member2, [unit]);
.Ve
.PP
Returns the distance between two members of a geospatial index.
.PP
See <https://redis.io/commands/geodist> for more information.
.SS "geohash"
.IX Subsection "geohash"
.Vb 3
\&  $res     = $db\->geohash($key, $member [member ...]);
\&  $db      = $db\->geohash($key, $member [member ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->geohash_p($key, $member [member ...]);
.Ve
.PP
Returns members of a geospatial index as standard geohash strings.
.PP
See <https://redis.io/commands/geohash> for more information.
.SS "geopos"
.IX Subsection "geopos"
.Vb 3
\&  $array_ref = $db\->geopos($key, $member [member ...]);
\&  $db        = $db\->geopos($key, $member [member ...], sub { my ($db, $err, $array_ref) = @_ });
\&  $promise   = $db\->geopos_p($key, $member [member ...]);
.Ve
.PP
Returns longitude and latitude of members of a geospatial index:
.PP
.Vb 1
\&  [{lat => $num, lng => $num}, ...]
.Ve
.PP
See <https://redis.io/commands/geopos> for more information.
.SS "georadius"
.IX Subsection "georadius"
.Vb 3
\&  $res     = $db\->georadius($key, $longitude, $latitude, $radius, $m|km|ft|mi, [WITHCOORD],[WITHDIST], [WITHHASH], [COUNT count], [ASC|DESC], [STORE key], [STOREDIST key]);
\&  $db      = $db\->georadius($key, $longitude, $latitude, $radius, $m|km|ft|mi, [WITHCOORD],[WITHDIST], [WITHHASH], [COUNT count], [ASC|DESC], [STORE key], [STOREDIST key], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->georadius_p($key, $longitude, $latitude, $radius, $m|km|ft|mi, [WITHCOORD], [WITHDIST], [WITHHASH], [COUNT count], [ASC|DESC], [STORE key], [STOREDIST key]);
.Ve
.PP
Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point.
.PP
See <https://redis.io/commands/georadius> for more information.
.SS "georadiusbymember"
.IX Subsection "georadiusbymember"
.Vb 3
\&  $res     = $db\->georadiusbymember($key, $member, $radius, $m|km|ft|mi, [WITHCOORD], [WITHDIST], [WITHHASH], [COUNT count], [ASC|DESC], [STORE key], [STOREDIST key]);
\&  $db      = $db\->georadiusbymember($key, $member, $radius, $m|km|ft|mi, [WITHCOORD], [WITHDIST], [WITHHASH], [COUNT count], [ASC|DESC], [STORE key], [STOREDIST key], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->georadiusbymember_p($key, $member, $radius, $m|km|ft|mi, [WITHCOORD], [WITHDIST], [WITHHASH], [COUNT count], [ASC|DESC], [STORE key], [STOREDIST key]);
.Ve
.PP
Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member.
.PP
See <https://redis.io/commands/georadiusbymember> for more information.
.SS "get"
.IX Subsection "get"
.Vb 3
\&  $res     = $db\->get($key);
\&  $db      = $db\->get($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->get_p($key);
.Ve
.PP
Get the value of a key.
.PP
See <https://redis.io/commands/get> for more information.
.SS "getbit"
.IX Subsection "getbit"
.Vb 3
\&  $res     = $db\->getbit($key, $offset);
\&  $db      = $db\->getbit($key, $offset, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->getbit_p($key, $offset);
.Ve
.PP
Returns the bit value at offset in the string value stored at key.
.PP
See <https://redis.io/commands/getbit> for more information.
.SS "getrange"
.IX Subsection "getrange"
.Vb 3
\&  $res     = $db\->getrange($key, $start, $end);
\&  $db      = $db\->getrange($key, $start, $end, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->getrange_p($key, $start, $end);
.Ve
.PP
Get a substring of the string stored at a key.
.PP
See <https://redis.io/commands/getrange> for more information.
.SS "getset"
.IX Subsection "getset"
.Vb 3
\&  $res     = $db\->getset($key, $value);
\&  $db      = $db\->getset($key, $value, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->getset_p($key, $value);
.Ve
.PP
Set the string value of a key and return its old value.
.PP
See <https://redis.io/commands/getset> for more information.
.SS "hdel"
.IX Subsection "hdel"
.Vb 3
\&  $res     = $db\->hdel($key, $field [field ...]);
\&  $db      = $db\->hdel($key, $field [field ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->hdel_p($key, $field [field ...]);
.Ve
.PP
Delete one or more hash fields.
.PP
See <https://redis.io/commands/hdel> for more information.
.SS "hexists"
.IX Subsection "hexists"
.Vb 3
\&  $res     = $db\->hexists($key, $field);
\&  $db      = $db\->hexists($key, $field, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->hexists_p($key, $field);
.Ve
.PP
Determine if a hash field exists.
.PP
See <https://redis.io/commands/hexists> for more information.
.SS "hget"
.IX Subsection "hget"
.Vb 3
\&  $res     = $db\->hget($key, $field);
\&  $db      = $db\->hget($key, $field, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->hget_p($key, $field);
.Ve
.PP
Get the value of a hash field.
.PP
See <https://redis.io/commands/hget> for more information.
.SS "hgetall"
.IX Subsection "hgetall"
.Vb 3
\&  $res     = $db\->hgetall($key);
\&  $db      = $db\->hgetall($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->hgetall_p($key);
.Ve
.PP
Get all the fields and values in a hash. The returned value from Redis is
automatically turned into a hash-ref for convenience.
.PP
See <https://redis.io/commands/hgetall> for more information.
.SS "hincrby"
.IX Subsection "hincrby"
.Vb 3
\&  $res     = $db\->hincrby($key, $field, $increment);
\&  $db      = $db\->hincrby($key, $field, $increment, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->hincrby_p($key, $field, $increment);
.Ve
.PP
Increment the integer value of a hash field by the given number.
.PP
See <https://redis.io/commands/hincrby> for more information.
.SS "hincrbyfloat"
.IX Subsection "hincrbyfloat"
.Vb 3
\&  $res     = $db\->hincrbyfloat($key, $field, $increment);
\&  $db      = $db\->hincrbyfloat($key, $field, $increment, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->hincrbyfloat_p($key, $field, $increment);
.Ve
.PP
Increment the float value of a hash field by the given amount.
.PP
See <https://redis.io/commands/hincrbyfloat> for more information.
.SS "hkeys"
.IX Subsection "hkeys"
.Vb 3
\&  $res     = $db\->hkeys($key);
\&  $db      = $db\->hkeys($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->hkeys_p($key);
.Ve
.PP
Get all the fields in a hash.
.PP
See <https://redis.io/commands/hkeys> for more information.
.SS "hlen"
.IX Subsection "hlen"
.Vb 3
\&  $res     = $db\->hlen($key);
\&  $db      = $db\->hlen($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->hlen_p($key);
.Ve
.PP
Get the number of fields in a hash.
.PP
See <https://redis.io/commands/hlen> for more information.
.SS "hmget"
.IX Subsection "hmget"
.Vb 3
\&  $res     = $db\->hmget($key, $field [field ...]);
\&  $db      = $db\->hmget($key, $field [field ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->hmget_p($key, $field [field ...]);
.Ve
.PP
Get the values of all the given hash fields.
.PP
See <https://redis.io/commands/hmget> for more information.
.SS "hmset"
.IX Subsection "hmset"
.Vb 3
\&  $res     = $db\->hmset($key, $field => $value [field value ...]);
\&  $db      = $db\->hmset($key, $field => $value [field value ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->hmset_p($key, $field => $value [field value ...]);
.Ve
.PP
Set multiple hash fields to multiple values.
.PP
See <https://redis.io/commands/hmset> for more information.
.SS "hset"
.IX Subsection "hset"
.Vb 3
\&  $res     = $db\->hset($key, $field, $value);
\&  $db      = $db\->hset($key, $field, $value, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->hset_p($key, $field, $value);
.Ve
.PP
Set the string value of a hash field.
.PP
See <https://redis.io/commands/hset> for more information.
.SS "hsetnx"
.IX Subsection "hsetnx"
.Vb 3
\&  $res     = $db\->hsetnx($key, $field, $value);
\&  $db      = $db\->hsetnx($key, $field, $value, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->hsetnx_p($key, $field, $value);
.Ve
.PP
Set the value of a hash field, only if the field does not exist.
.PP
See <https://redis.io/commands/hsetnx> for more information.
.SS "hstrlen"
.IX Subsection "hstrlen"
.Vb 3
\&  $res     = $db\->hstrlen($key, $field);
\&  $db      = $db\->hstrlen($key, $field, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->hstrlen_p($key, $field);
.Ve
.PP
Get the length of the value of a hash field.
.PP
See <https://redis.io/commands/hstrlen> for more information.
.SS "hvals"
.IX Subsection "hvals"
.Vb 3
\&  $res     = $db\->hvals($key);
\&  $db      = $db\->hvals($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->hvals_p($key);
.Ve
.PP
Get all the values in a hash.
.PP
See <https://redis.io/commands/hvals> for more information.
.SS "info"
.IX Subsection "info"
.Vb 3
\&  $res     = $db\->info($section);
\&  $db      = $db\->info($section, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->info_p($section);
.Ve
.PP
Get information and statistics about the server. See also \*(L"info_structured\*(R".
.PP
See <https://redis.io/commands/info> for more information.
.SS "info_structured"
.IX Subsection "info_structured"
Same as \*(L"info\*(R", but the result is a hash-ref where the keys are the different
sections, with key/values in a sub hash. Will only be key/values if <$section>
is specified.
.SS "incr"
.IX Subsection "incr"
.Vb 3
\&  $res     = $db\->incr($key);
\&  $db      = $db\->incr($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->incr_p($key);
.Ve
.PP
Increment the integer value of a key by one.
.PP
See <https://redis.io/commands/incr> for more information.
.SS "incrby"
.IX Subsection "incrby"
.Vb 3
\&  $res     = $db\->incrby($key, $increment);
\&  $db      = $db\->incrby($key, $increment, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->incrby_p($key, $increment);
.Ve
.PP
Increment the integer value of a key by the given amount.
.PP
See <https://redis.io/commands/incrby> for more information.
.SS "incrbyfloat"
.IX Subsection "incrbyfloat"
.Vb 3
\&  $res     = $db\->incrbyfloat($key, $increment);
\&  $db      = $db\->incrbyfloat($key, $increment, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->incrbyfloat_p($key, $increment);
.Ve
.PP
Increment the float value of a key by the given amount.
.PP
See <https://redis.io/commands/incrbyfloat> for more information.
.SS "keys"
.IX Subsection "keys"
.Vb 3
\&  $res     = $db\->keys($pattern);
\&  $db      = $db\->keys($pattern, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->keys_p($pattern);
.Ve
.PP
Find all keys matching the given pattern.
.PP
See <https://redis.io/commands/keys> for more information.
.SS "lastsave"
.IX Subsection "lastsave"
.Vb 3
\&  $res     = $db\->lastsave;
\&  $db      = $db\->lastsave(sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->lastsave_p;
.Ve
.PP
Get the \s-1UNIX\s0 time stamp of the last successful save to disk.
.PP
See <https://redis.io/commands/lastsave> for more information.
.SS "lindex"
.IX Subsection "lindex"
.Vb 3
\&  $res     = $db\->lindex($key, $index);
\&  $db      = $db\->lindex($key, $index, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->lindex_p($key, $index);
.Ve
.PP
Get an element from a list by its index.
.PP
See <https://redis.io/commands/lindex> for more information.
.SS "linsert"
.IX Subsection "linsert"
.Vb 3
\&  $res     = $db\->linsert($key, $BEFORE|AFTER, $pivot, $value);
\&  $db      = $db\->linsert($key, $BEFORE|AFTER, $pivot, $value, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->linsert_p($key, $BEFORE|AFTER, $pivot, $value);
.Ve
.PP
Insert an element before or after another element in a list.
.PP
See <https://redis.io/commands/linsert> for more information.
.SS "llen"
.IX Subsection "llen"
.Vb 3
\&  $res     = $db\->llen($key);
\&  $db      = $db\->llen($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->llen_p($key);
.Ve
.PP
Get the length of a list.
.PP
See <https://redis.io/commands/llen> for more information.
.SS "lpop"
.IX Subsection "lpop"
.Vb 3
\&  $res     = $db\->lpop($key);
\&  $db      = $db\->lpop($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->lpop_p($key);
.Ve
.PP
Remove and get the first element in a list.
.PP
See <https://redis.io/commands/lpop> for more information.
.SS "lpush"
.IX Subsection "lpush"
.Vb 3
\&  $res     = $db\->lpush($key, $value [value ...]);
\&  $db      = $db\->lpush($key, $value [value ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->lpush_p($key, $value [value ...]);
.Ve
.PP
Prepend one or multiple values to a list.
.PP
See <https://redis.io/commands/lpush> for more information.
.SS "lpushx"
.IX Subsection "lpushx"
.Vb 3
\&  $res     = $db\->lpushx($key, $value);
\&  $db      = $db\->lpushx($key, $value, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->lpushx_p($key, $value);
.Ve
.PP
Prepend a value to a list, only if the list exists.
.PP
See <https://redis.io/commands/lpushx> for more information.
.SS "lrange"
.IX Subsection "lrange"
.Vb 3
\&  $res     = $db\->lrange($key, $start, $stop);
\&  $db      = $db\->lrange($key, $start, $stop, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->lrange_p($key, $start, $stop);
.Ve
.PP
Get a range of elements from a list.
.PP
See <https://redis.io/commands/lrange> for more information.
.SS "lrem"
.IX Subsection "lrem"
.Vb 3
\&  $res     = $db\->lrem($key, $count, $value);
\&  $db      = $db\->lrem($key, $count, $value, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->lrem_p($key, $count, $value);
.Ve
.PP
Remove elements from a list.
.PP
See <https://redis.io/commands/lrem> for more information.
.SS "lset"
.IX Subsection "lset"
.Vb 3
\&  $res     = $db\->lset($key, $index, $value);
\&  $db      = $db\->lset($key, $index, $value, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->lset_p($key, $index, $value);
.Ve
.PP
Set the value of an element in a list by its index.
.PP
See <https://redis.io/commands/lset> for more information.
.SS "ltrim"
.IX Subsection "ltrim"
.Vb 3
\&  $res     = $db\->ltrim($key, $start, $stop);
\&  $db      = $db\->ltrim($key, $start, $stop, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->ltrim_p($key, $start, $stop);
.Ve
.PP
Trim a list to the specified range.
.PP
See <https://redis.io/commands/ltrim> for more information.
.SS "mget"
.IX Subsection "mget"
.Vb 3
\&  $res     = $db\->mget($key [key ...]);
\&  $db      = $db\->mget($key [key ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->mget_p($key [key ...]);
.Ve
.PP
Get the values of all the given keys.
.PP
See <https://redis.io/commands/mget> for more information.
.SS "move"
.IX Subsection "move"
.Vb 3
\&  $res     = $db\->move($key, $db);
\&  $db      = $db\->move($key, $db, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->move_p($key, $db);
.Ve
.PP
Move a key to another database.
.PP
See <https://redis.io/commands/move> for more information.
.SS "mset"
.IX Subsection "mset"
.Vb 3
\&  $res     = $db\->mset($key value [key value ...]);
\&  $db      = $db\->mset($key value [key value ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->mset_p($key value [key value ...]);
.Ve
.PP
Set multiple keys to multiple values.
.PP
See <https://redis.io/commands/mset> for more information.
.SS "msetnx"
.IX Subsection "msetnx"
.Vb 3
\&  $res     = $db\->msetnx($key value [key value ...]);
\&  $db      = $db\->msetnx($key value [key value ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->msetnx_p($key value [key value ...]);
.Ve
.PP
Set multiple keys to multiple values, only if none of the keys exist.
.PP
See <https://redis.io/commands/msetnx> for more information.
.SS "multi"
.IX Subsection "multi"
See \*(L"multi_p\*(R".
.SS "multi_p"
.IX Subsection "multi_p"
.Vb 4
\&  $res     = $db\->multi;
\&  $db      = $db\->multi(sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->multi_p;
\&  $promise = $db\->multi_p(@promises);
.Ve
.PP
Mark the start of a transaction block. Commands issued after \*(L"multi\*(R" will
automatically be discarded if \f(CW$db\fR goes out of scope. Need to call
\&\*(L"exec\*(R" to commit the queued commands to Redis.
.PP
When calling \*(L"multi_p\*(R", you can directly pass in the new instructions:
.PP
.Vb 7
\&  $db\->multi_p(
\&    $db\->set_p("x:y:z" => 1011),
\&    $db\->get_p("x:y:z"),
\&    $db\->incr_p("x:y:z"),
\&    $db\->incrby_p("x:y:z" => \-10),
\&  )\->then(sub {
\&  });
.Ve
.PP
See <https://redis.io/commands/multi> for more information.
.SS "object"
.IX Subsection "object"
.Vb 3
\&  $res     = $db\->object($subcommand, [arguments [arguments ...]]);
\&  $db      = $db\->object($subcommand, [arguments [arguments ...]], sub { my ($db, $err, $res) =@_ });
\&  $promise = $db\->object_p($subcommand, [arguments [arguments ...]]);
.Ve
.PP
Inspect the internals of Redis objects.
.PP
See <https://redis.io/commands/object> for more information.
.SS "persist"
.IX Subsection "persist"
.Vb 3
\&  $res     = $db\->persist($key);
\&  $db      = $db\->persist($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->persist_p($key);
.Ve
.PP
Remove the expiration from a key.
.PP
See <https://redis.io/commands/persist> for more information.
.SS "pexpire"
.IX Subsection "pexpire"
.Vb 3
\&  $res     = $db\->pexpire($key, $milliseconds);
\&  $db      = $db\->pexpire($key, $milliseconds, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->pexpire_p($key, $milliseconds);
.Ve
.PP
Set a key's time to live in milliseconds.
.PP
See <https://redis.io/commands/pexpire> for more information.
.SS "pexpireat"
.IX Subsection "pexpireat"
.Vb 3
\&  $res     = $db\->pexpireat($key, $milliseconds\-timestamp);
\&  $db      = $db\->pexpireat($key, $milliseconds\-timestamp, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->pexpireat_p($key, $milliseconds\-timestamp);
.Ve
.PP
Set the expiration for a key as a \s-1UNIX\s0 timestamp specified in milliseconds.
.PP
See <https://redis.io/commands/pexpireat> for more information.
.SS "pfadd"
.IX Subsection "pfadd"
.Vb 3
\&  $res     = $db\->pfadd($key, $element [element ...]);
\&  $db      = $db\->pfadd($key, $element [element ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->pfadd_p($key, $element [element ...]);
.Ve
.PP
Adds the specified elements to the specified HyperLogLog.
.PP
See <https://redis.io/commands/pfadd> for more information.
.SS "pfcount"
.IX Subsection "pfcount"
.Vb 3
\&  $res     = $db\->pfcount($key [key ...]);
\&  $db      = $db\->pfcount($key [key ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->pfcount_p($key [key ...]);
.Ve
.PP
Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).
.PP
See <https://redis.io/commands/pfcount> for more information.
.SS "pfmerge"
.IX Subsection "pfmerge"
.Vb 3
\&  $res     = $db\->pfmerge($destkey, $sourcekey [sourcekey ...]);
\&  $db      = $db\->pfmerge($destkey, $sourcekey [sourcekey ...], sub { my ($db, $err, $res) = @_});
\&  $promise = $db\->pfmerge_p($destkey, $sourcekey [sourcekey ...]);
.Ve
.PP
Merge N different HyperLogLogs into a single one.
.PP
See <https://redis.io/commands/pfmerge> for more information.
.SS "ping"
.IX Subsection "ping"
.Vb 3
\&  $res     = $db\->ping([message]);
\&  $db      = $db\->ping([message], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->ping_p([message]);
.Ve
.PP
Ping the server.
.PP
See <https://redis.io/commands/ping> for more information.
.SS "psetex"
.IX Subsection "psetex"
.Vb 3
\&  $res     = $db\->psetex($key, $milliseconds, $value);
\&  $db      = $db\->psetex($key, $milliseconds, $value, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->psetex_p($key, $milliseconds, $value);
.Ve
.PP
Set the value and expiration in milliseconds of a key.
.PP
See <https://redis.io/commands/psetex> for more information.
.SS "pttl"
.IX Subsection "pttl"
.Vb 3
\&  $res     = $db\->pttl($key);
\&  $db      = $db\->pttl($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->pttl_p($key);
.Ve
.PP
Get the time to live for a key in milliseconds.
.PP
See <https://redis.io/commands/pttl> for more information.
.SS "publish"
.IX Subsection "publish"
.Vb 3
\&  $res     = $db\->publish($channel, $message);
\&  $db      = $db\->publish($channel, $message, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->publish_p($channel, $message);
.Ve
.PP
Post a message to a channel.
.PP
See <https://redis.io/commands/publish> for more information.
.SS "randomkey"
.IX Subsection "randomkey"
.Vb 3
\&  $res     = $db\->randomkey;
\&  $db      = $db\->randomkey(sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->randomkey_p;
.Ve
.PP
Return a random key from the keyspace.
.PP
See <https://redis.io/commands/randomkey> for more information.
.SS "readonly"
.IX Subsection "readonly"
.Vb 3
\&  $res     = $db\->readonly();
\&  $db      = $db\->readonly(, sub { my ($db, $res) = @_ });
\&  $promise = $db\->readonly_p();
.Ve
.PP
Enables read queries for a connection to a cluster slave node.
.PP
See <https://redis.io/commands/readonly> for more information.
.SS "readwrite"
.IX Subsection "readwrite"
.Vb 3
\&  $res     = $db\->readwrite();
\&  $db      = $db\->readwrite(, sub { my ($db, $res) = @_ });
\&  $promise = $db\->readwrite_p();
.Ve
.PP
Disables read queries for a connection to a cluster slave node.
.PP
See <https://redis.io/commands/readwrite> for more information.
.SS "rename"
.IX Subsection "rename"
.Vb 3
\&  $res     = $db\->rename($key, $newkey);
\&  $db      = $db\->rename($key, $newkey, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->rename_p($key, $newkey);
.Ve
.PP
Rename a key.
.PP
See <https://redis.io/commands/rename> for more information.
.SS "renamenx"
.IX Subsection "renamenx"
.Vb 3
\&  $res     = $db\->renamenx($key, $newkey);
\&  $db      = $db\->renamenx($key, $newkey, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->renamenx_p($key, $newkey);
.Ve
.PP
Rename a key, only if the new key does not exist.
.PP
See <https://redis.io/commands/renamenx> for more information.
.SS "role"
.IX Subsection "role"
.Vb 3
\&  $res     = $db\->role;
\&  $db      = $db\->role(sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->role_p;
.Ve
.PP
Return the role of the instance in the context of replication.
.PP
See <https://redis.io/commands/role> for more information.
.SS "rpop"
.IX Subsection "rpop"
.Vb 3
\&  $res     = $db\->rpop($key);
\&  $db      = $db\->rpop($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->rpop_p($key);
.Ve
.PP
Remove and get the last element in a list.
.PP
See <https://redis.io/commands/rpop> for more information.
.SS "rpoplpush"
.IX Subsection "rpoplpush"
.Vb 3
\&  $res     = $db\->rpoplpush($source, $destination);
\&  $db      = $db\->rpoplpush($source, $destination, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->rpoplpush_p($source, $destination);
.Ve
.PP
Remove the last element in a list, prepend it to another list and return it.
.PP
See <https://redis.io/commands/rpoplpush> for more information.
.SS "rpush"
.IX Subsection "rpush"
.Vb 3
\&  $res     = $db\->rpush($key, $value [value ...]);
\&  $db      = $db\->rpush($key, $value [value ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->rpush_p($key, $value [value ...]);
.Ve
.PP
Append one or multiple values to a list.
.PP
See <https://redis.io/commands/rpush> for more information.
.SS "rpushx"
.IX Subsection "rpushx"
.Vb 3
\&  $res     = $db\->rpushx($key, $value);
\&  $db      = $db\->rpushx($key, $value, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->rpushx_p($key, $value);
.Ve
.PP
Append a value to a list, only if the list exists.
.PP
See <https://redis.io/commands/rpushx> for more information.
.SS "restore"
.IX Subsection "restore"
.Vb 3
\&  $res     = $db\->restore($key, $ttl, $serialized\-value, [REPLACE]);
\&  $db      = $db\->restore($key, $ttl, $serialized\-value, [REPLACE], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->restore_p($key, $ttl, $serialized\-value, [REPLACE]);
.Ve
.PP
Create a key using the provided serialized value, previously obtained using \s-1DUMP.\s0
.PP
See <https://redis.io/commands/restore> for more information.
.SS "sadd"
.IX Subsection "sadd"
.Vb 3
\&  $res     = $db\->sadd($key, $member [member ...]);
\&  $db      = $db\->sadd($key, $member [member ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->sadd_p($key, $member [member ...]);
.Ve
.PP
Add one or more members to a set.
.PP
See <https://redis.io/commands/sadd> for more information.
.SS "save"
.IX Subsection "save"
.Vb 3
\&  $res     = $db\->save;
\&  $db      = $db\->save(sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->save_p;
.Ve
.PP
Synchronously save the dataset to disk.
.PP
See <https://redis.io/commands/save> for more information.
.SS "scard"
.IX Subsection "scard"
.Vb 3
\&  $res     = $db\->scard($key);
\&  $db      = $db\->scard($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->scard_p($key);
.Ve
.PP
Get the number of members in a set.
.PP
See <https://redis.io/commands/scard> for more information.
.SS "script"
.IX Subsection "script"
.Vb 3
\&  $res     = $db\->script($sub_command, @args);
\&  $db      = $db\->script($sub_command, @args, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->script_p($sub_command, @args);
.Ve
.PP
Execute a script command.
.PP
See <https://redis.io/commands/script\-debug>,
<https://redis.io/commands/script\-exists>,
<https://redis.io/commands/script\-flush>,
<https://redis.io/commands/script\-kill> or
<https://redis.io/commands/script\-load> for more information.
.SS "sdiff"
.IX Subsection "sdiff"
.Vb 3
\&  $res     = $db\->sdiff($key [key ...]);
\&  $db      = $db\->sdiff($key [key ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->sdiff_p($key [key ...]);
.Ve
.PP
Subtract multiple sets.
.PP
See <https://redis.io/commands/sdiff> for more information.
.SS "sdiffstore"
.IX Subsection "sdiffstore"
.Vb 3
\&  $res     = $db\->sdiffstore($destination, $key [key ...]);
\&  $db      = $db\->sdiffstore($destination, $key [key ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->sdiffstore_p($destination, $key [key ...]);
.Ve
.PP
Subtract multiple sets and store the resulting set in a key.
.PP
See <https://redis.io/commands/sdiffstore> for more information.
.SS "set"
.IX Subsection "set"
.Vb 3
\&  $res     = $db\->set($key, $value, [expiration EX seconds|PX milliseconds], [NX|XX]);
\&  $db      = $db\->set($key, $value, [expiration EX seconds|PX milliseconds], [NX|XX], sub {my ($db, $err, $res) = @_ });
\&  $promise = $db\->set_p($key, $value, [expiration EX seconds|PX milliseconds], [NX|XX]);
.Ve
.PP
Set the string value of a key.
.PP
See <https://redis.io/commands/set> for more information.
.SS "setbit"
.IX Subsection "setbit"
.Vb 3
\&  $res     = $db\->setbit($key, $offset, $value);
\&  $db      = $db\->setbit($key, $offset, $value, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->setbit_p($key, $offset, $value);
.Ve
.PP
Sets or clears the bit at offset in the string value stored at key.
.PP
See <https://redis.io/commands/setbit> for more information.
.SS "setex"
.IX Subsection "setex"
.Vb 3
\&  $res     = $db\->setex($key, $seconds, $value);
\&  $db      = $db\->setex($key, $seconds, $value, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->setex_p($key, $seconds, $value);
.Ve
.PP
Set the value and expiration of a key.
.PP
See <https://redis.io/commands/setex> for more information.
.SS "setnx"
.IX Subsection "setnx"
.Vb 3
\&  $res     = $db\->setnx($key, $value);
\&  $db      = $db\->setnx($key, $value, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->setnx_p($key, $value);
.Ve
.PP
Set the value of a key, only if the key does not exist.
.PP
See <https://redis.io/commands/setnx> for more information.
.SS "setrange"
.IX Subsection "setrange"
.Vb 3
\&  $res     = $db\->setrange($key, $offset, $value);
\&  $db      = $db\->setrange($key, $offset, $value, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->setrange_p($key, $offset, $value);
.Ve
.PP
Overwrite part of a string at key starting at the specified offset.
.PP
See <https://redis.io/commands/setrange> for more information.
.SS "sinter"
.IX Subsection "sinter"
.Vb 3
\&  $res     = $db\->sinter($key [key ...]);
\&  $db      = $db\->sinter($key [key ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->sinter_p($key [key ...]);
.Ve
.PP
Intersect multiple sets.
.PP
See <https://redis.io/commands/sinter> for more information.
.SS "sinterstore"
.IX Subsection "sinterstore"
.Vb 3
\&  $res     = $db\->sinterstore($destination, $key [key ...]);
\&  $db      = $db\->sinterstore($destination, $key [key ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->sinterstore_p($destination, $key [key ...]);
.Ve
.PP
Intersect multiple sets and store the resulting set in a key.
.PP
See <https://redis.io/commands/sinterstore> for more information.
.SS "sismember"
.IX Subsection "sismember"
.Vb 3
\&  $res     = $db\->sismember($key, $member);
\&  $db      = $db\->sismember($key, $member, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->sismember_p($key, $member);
.Ve
.PP
Determine if a given value is a member of a set.
.PP
See <https://redis.io/commands/sismember> for more information.
.SS "slaveof"
.IX Subsection "slaveof"
.Vb 3
\&  $res     = $db\->slaveof($host, $port);
\&  $db      = $db\->slaveof($host, $port, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->slaveof_p($host, $port);
.Ve
.PP
Make the server a slave of another instance, or promote it as master.
.PP
See <https://redis.io/commands/slaveof> for more information.
.SS "slowlog"
.IX Subsection "slowlog"
.Vb 3
\&  $res     = $db\->slowlog($subcommand, [argument]);
\&  $db      = $db\->slowlog($subcommand, [argument], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->slowlog_p($subcommand, [argument]);
.Ve
.PP
Manages the Redis slow queries log.
.PP
See <https://redis.io/commands/slowlog> for more information.
.SS "smembers"
.IX Subsection "smembers"
.Vb 3
\&  $res     = $db\->smembers($key);
\&  $db      = $db\->smembers($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->smembers_p($key);
.Ve
.PP
Get all the members in a set.
.PP
See <https://redis.io/commands/smembers> for more information.
.SS "smove"
.IX Subsection "smove"
.Vb 3
\&  $res     = $db\->smove($source, $destination, $member);
\&  $db      = $db\->smove($source, $destination, $member, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->smove_p($source, $destination, $member);
.Ve
.PP
Move a member from one set to another.
.PP
See <https://redis.io/commands/smove> for more information.
.SS "sort"
.IX Subsection "sort"
.Vb 3
\&  $res     = $db\->sort($key, [BY pattern], [LIMIT offset count], [GET pattern [GET pattern ...]], [ASC|DESC], [ALPHA], [STORE destination]);
\&  $db      = $db\->sort($key, [BY pattern], [LIMIT offset count], [GET pattern [GET pattern ...]], [ASC|DESC], [ALPHA], [STORE destination], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->sort_p($key, [BY pattern], [LIMIT offset count], [GET pattern [GET pattern ...]], [ASC|DESC], [ALPHA], [STORE destination]);
.Ve
.PP
Sort the elements in a list, set or sorted set.
.PP
See <https://redis.io/commands/sort> for more information.
.SS "spop"
.IX Subsection "spop"
.Vb 3
\&  $res     = $db\->spop($key, [count]);
\&  $db      = $db\->spop($key, [count], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->spop_p($key, [count]);
.Ve
.PP
Remove and return one or multiple random members from a set.
.PP
See <https://redis.io/commands/spop> for more information.
.SS "srandmember"
.IX Subsection "srandmember"
.Vb 3
\&  $res     = $db\->srandmember($key, [count]);
\&  $db      = $db\->srandmember($key, [count], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->srandmember_p($key, [count]);
.Ve
.PP
Get one or multiple random members from a set.
.PP
See <https://redis.io/commands/srandmember> for more information.
.SS "srem"
.IX Subsection "srem"
.Vb 3
\&  $res     = $db\->srem($key, $member [member ...]);
\&  $db      = $db\->srem($key, $member [member ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->srem_p($key, $member [member ...]);
.Ve
.PP
Remove one or more members from a set.
.PP
See <https://redis.io/commands/srem> for more information.
.SS "strlen"
.IX Subsection "strlen"
.Vb 3
\&  $res     = $db\->strlen($key);
\&  $db      = $db\->strlen($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->strlen_p($key);
.Ve
.PP
Get the length of the value stored in a key.
.PP
See <https://redis.io/commands/strlen> for more information.
.SS "sunion"
.IX Subsection "sunion"
.Vb 3
\&  $res     = $db\->sunion($key [key ...]);
\&  $db      = $db\->sunion($key [key ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->sunion_p($key [key ...]);
.Ve
.PP
Add multiple sets.
.PP
See <https://redis.io/commands/sunion> for more information.
.SS "sunionstore"
.IX Subsection "sunionstore"
.Vb 3
\&  $res     = $db\->sunionstore($destination, $key [key ...]);
\&  $db      = $db\->sunionstore($destination, $key [key ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->sunionstore_p($destination, $key [key ...]);
.Ve
.PP
Add multiple sets and store the resulting set in a key.
.PP
See <https://redis.io/commands/sunionstore> for more information.
.SS "time"
.IX Subsection "time"
.Vb 3
\&  $res     = $db\->time;
\&  $db      = $db\->time(sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->time_p;
.Ve
.PP
Return the current server time.
.PP
See <https://redis.io/commands/time> for more information.
.SS "touch"
.IX Subsection "touch"
.Vb 3
\&  $res     = $db\->touch($key [key ...]);
\&  $db      = $db\->touch($key [key ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->touch_p($key [key ...]);
.Ve
.PP
Alters the last access time of a key(s). Returns the number of existing keys specified.
.PP
See <https://redis.io/commands/touch> for more information.
.SS "ttl"
.IX Subsection "ttl"
.Vb 3
\&  $res     = $db\->ttl($key);
\&  $db      = $db\->ttl($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->ttl_p($key);
.Ve
.PP
Get the time to live for a key.
.PP
See <https://redis.io/commands/ttl> for more information.
.SS "type"
.IX Subsection "type"
.Vb 3
\&  $res     = $db\->type($key);
\&  $db      = $db\->type($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->type_p($key);
.Ve
.PP
Determine the type stored at key.
.PP
See <https://redis.io/commands/type> for more information.
.SS "unlink"
.IX Subsection "unlink"
.Vb 3
\&  $res     = $db\->unlink($key [key ...]);
\&  $db      = $db\->unlink($key [key ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->unlink_p($key [key ...]);
.Ve
.PP
Delete a key asynchronously in another thread. Otherwise it is just as \s-1DEL,\s0 but non blocking.
.PP
See <https://redis.io/commands/unlink> for more information.
.SS "unwatch"
.IX Subsection "unwatch"
.Vb 3
\&  $res     = $db\->unwatch;
\&  $db      = $db\->unwatch(sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->unwatch_p;
.Ve
.PP
Forget about all watched keys.
.PP
See <https://redis.io/commands/unwatch> for more information.
.SS "watch"
.IX Subsection "watch"
.Vb 3
\&  $res     = $db\->watch($key [key ...]);
\&  $db      = $db\->watch($key [key ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->watch_p($key [key ...]);
.Ve
.PP
Watch the given keys to determine execution of the \s-1MULTI/EXEC\s0 block.
.PP
See <https://redis.io/commands/watch> for more information.
.SS "xadd"
.IX Subsection "xadd"
.Vb 3
\&  $res     = $db\->xadd($key, $ID, $field string [field string ...]);
\&  $db      = $db\->xadd($key, $ID, $field string [field string ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->xadd_p($key, $ID, $field string [field string ...]);
.Ve
.PP
Appends a new entry to a stream.
.PP
See <https://redis.io/commands/xadd> for more information.
.SS "xlen"
.IX Subsection "xlen"
.Vb 3
\&  $res     = $db\->xlen($key);
\&  $db      = $db\->xlen($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->xlen_p($key);
.Ve
.PP
Return the number of entires in a stream.
.PP
See <https://redis.io/commands/xlen> for more information.
.SS "xpending"
.IX Subsection "xpending"
.Vb 3
\&  $res     = $db\->xpending($key, $group, [start end count], [consumer]);
\&  $db      = $db\->xpending($key, $group, [start end count], [consumer], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->xpending_p($key, $group, [start end count], [consumer]);
.Ve
.PP
Return information and entries from a stream consumer group pending entries list, that are messages fetched but never acknowledged.
.PP
See <https://redis.io/commands/xpending> for more information.
.SS "xrange"
.IX Subsection "xrange"
.Vb 3
\&  $res     = $db\->xrange($key, $start, $end, [COUNT count]);
\&  $db      = $db\->xrange($key, $start, $end, [COUNT count], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->xrange_p($key, $start, $end, [COUNT count]);
.Ve
.PP
Return a range of elements in a stream, with IDs matching the specified IDs interval.
.PP
See <https://redis.io/commands/xrange> for more information.
.SS "xread"
.IX Subsection "xread"
.Vb 3
\&  $res     = $db\->xread([COUNT count], [BLOCK milliseconds], $STREAMS, $key [key ...], $ID [ID ...]);
\&  $db      = $db\->xread([COUNT count], [BLOCK milliseconds], $STREAMS, $key [key ...], $ID [ID ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->xread_p([COUNT count], [BLOCK milliseconds], $STREAMS, $key [key ...], $ID [ID ...]);
.Ve
.PP
Return never seen elements in multiple streams, with IDs greater than the ones reported by the caller for each stream. Can block.
.PP
See <https://redis.io/commands/xread> for more information.
.SS "xread_structured"
.IX Subsection "xread_structured"
Same as \*(L"xread\*(R", but the result is a data structure like this:
.PP
.Vb 7
\&  {
\&    $stream_name => [
\&      [ $id1 => [@data1] ],
\&      [ $id2 => [@data2] ],
\&      ...
\&    ]
\&  }
.Ve
.PP
This method is currently \s-1EXPERIMENTAL,\s0 but will only change if bugs are
discovered.
.SS "xreadgroup"
.IX Subsection "xreadgroup"
.Vb 3
\&  $res     = $db\->xreadgroup($GROUP group consumer, [COUNT count], [BLOCK milliseconds], $STREAMS, $key [key ...], $ID [ID ...]);
\&  $db      = $db\->xreadgroup($GROUP group consumer, [COUNT count], [BLOCK milliseconds], $STREAMS, $key [key ...], $ID [ID ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->xreadgroup_p($GROUP group consumer, [COUNT count], [BLOCK milliseconds], $STREAMS, $key [key ...], $ID [ID ...]);
.Ve
.PP
Return new entries from a stream using a consumer group, or access the history of the pending entries for a given consumer. Can block.
.PP
See <https://redis.io/commands/xreadgroup> for more information.
.SS "xrevrange"
.IX Subsection "xrevrange"
.Vb 3
\&  $res     = $db\->xrevrange($key, $end, $start, [COUNT count]);
\&  $db      = $db\->xrevrange($key, $end, $start, [COUNT count], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->xrevrange_p($key, $end, $start, [COUNT count]);
.Ve
.PP
Return a range of elements in a stream, with IDs matching the specified IDs interval, in reverse order (from greater to smaller IDs) compared to \s-1XRANGE.\s0
.PP
See <https://redis.io/commands/xrevrange> for more information.
.SS "zadd"
.IX Subsection "zadd"
.Vb 3
\&  $res     = $db\->zadd($key, [NX|XX], [CH], [INCR], $score member [score member ...]);
\&  $db      = $db\->zadd($key, [NX|XX], [CH], [INCR], $score member [score member ...], sub {my ($db, $err, $res) = @_ });
\&  $promise = $db\->zadd_p($key, [NX|XX], [CH], [INCR], $score member [score member ...]);
.Ve
.PP
Add one or more members to a sorted set, or update its score if it already exists.
.PP
See <https://redis.io/commands/zadd> for more information.
.SS "zcard"
.IX Subsection "zcard"
.Vb 3
\&  $res     = $db\->zcard($key);
\&  $db      = $db\->zcard($key, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zcard_p($key);
.Ve
.PP
Get the number of members in a sorted set.
.PP
See <https://redis.io/commands/zcard> for more information.
.SS "zcount"
.IX Subsection "zcount"
.Vb 3
\&  $res     = $db\->zcount($key, $min, $max);
\&  $db      = $db\->zcount($key, $min, $max, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zcount_p($key, $min, $max);
.Ve
.PP
Count the members in a sorted set with scores within the given values.
.PP
See <https://redis.io/commands/zcount> for more information.
.SS "zincrby"
.IX Subsection "zincrby"
.Vb 3
\&  $res     = $db\->zincrby($key, $increment, $member);
\&  $db      = $db\->zincrby($key, $increment, $member, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zincrby_p($key, $increment, $member);
.Ve
.PP
Increment the score of a member in a sorted set.
.PP
See <https://redis.io/commands/zincrby> for more information.
.SS "zinterstore"
.IX Subsection "zinterstore"
.Vb 3
\&  $res     = $db\->zinterstore($destination, $numkeys, $key [key ...], [WEIGHTS weight [weight ...]], [AGGREGATE SUM|MIN|MAX]);
\&  $db      = $db\->zinterstore($destination, $numkeys, $key [key ...], [WEIGHTS weight [weight ...]], [AGGREGATE SUM|MIN|MAX], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zinterstore_p($destination, $numkeys, $key [key ...], [WEIGHTS weight [weight ...]], [AGGREGATE SUM|MIN|MAX]);
.Ve
.PP
Intersect multiple sorted sets and store the resulting sorted set in a new key.
.PP
See <https://redis.io/commands/zinterstore> for more information.
.SS "zlexcount"
.IX Subsection "zlexcount"
.Vb 3
\&  $res     = $db\->zlexcount($key, $min, $max);
\&  $db      = $db\->zlexcount($key, $min, $max, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zlexcount_p($key, $min, $max);
.Ve
.PP
Count the number of members in a sorted set between a given lexicographical range.
.PP
See <https://redis.io/commands/zlexcount> for more information.
.SS "zpopmax"
.IX Subsection "zpopmax"
.Vb 3
\&  $res     = $db\->zpopmax($key, [count]);
\&  $db      = $db\->zpopmax($key, [count], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zpopmax_p($key, [count]);
.Ve
.PP
Remove and return members with the highest scores in a sorted set.
.PP
See <https://redis.io/commands/zpopmax> for more information.
.SS "zpopmin"
.IX Subsection "zpopmin"
.Vb 3
\&  $res     = $db\->zpopmin($key, [count]);
\&  $db      = $db\->zpopmin($key, [count], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zpopmin_p($key, [count]);
.Ve
.PP
Remove and return members with the lowest scores in a sorted set.
.PP
See <https://redis.io/commands/zpopmin> for more information.
.SS "zrange"
.IX Subsection "zrange"
.Vb 3
\&  $res     = $db\->zrange($key, $start, $stop, [WITHSCORES]);
\&  $db      = $db\->zrange($key, $start, $stop, [WITHSCORES], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zrange_p($key, $start, $stop, [WITHSCORES]);
.Ve
.PP
Return a range of members in a sorted set, by index.
.PP
See <https://redis.io/commands/zrange> for more information.
.SS "zrangebylex"
.IX Subsection "zrangebylex"
.Vb 3
\&  $res     = $db\->zrangebylex($key, $min, $max, [LIMIT offset count]);
\&  $db      = $db\->zrangebylex($key, $min, $max, [LIMIT offset count], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zrangebylex_p($key, $min, $max, [LIMIT offset count]);
.Ve
.PP
Return a range of members in a sorted set, by lexicographical range.
.PP
See <https://redis.io/commands/zrangebylex> for more information.
.SS "zrangebyscore"
.IX Subsection "zrangebyscore"
.Vb 3
\&  $res     = $db\->zrangebyscore($key, $min, $max, [WITHSCORES], [LIMIT offset count]);
\&  $db      = $db\->zrangebyscore($key, $min, $max, [WITHSCORES], [LIMIT offset count], sub {my ($db, $err, $res) = @_ });
\&  $promise = $db\->zrangebyscore_p($key, $min, $max, [WITHSCORES], [LIMIT offset count]);
.Ve
.PP
Return a range of members in a sorted set, by score.
.PP
See <https://redis.io/commands/zrangebyscore> for more information.
.SS "zrank"
.IX Subsection "zrank"
.Vb 3
\&  $res     = $db\->zrank($key, $member);
\&  $db      = $db\->zrank($key, $member, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zrank_p($key, $member);
.Ve
.PP
Determine the index of a member in a sorted set.
.PP
See <https://redis.io/commands/zrank> for more information.
.SS "zrem"
.IX Subsection "zrem"
.Vb 3
\&  $res     = $db\->zrem($key, $member [member ...]);
\&  $db      = $db\->zrem($key, $member [member ...], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zrem_p($key, $member [member ...]);
.Ve
.PP
Remove one or more members from a sorted set.
.PP
See <https://redis.io/commands/zrem> for more information.
.SS "zremrangebylex"
.IX Subsection "zremrangebylex"
.Vb 3
\&  $res     = $db\->zremrangebylex($key, $min, $max);
\&  $db      = $db\->zremrangebylex($key, $min, $max, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zremrangebylex_p($key, $min, $max);
.Ve
.PP
Remove all members in a sorted set between the given lexicographical range.
.PP
See <https://redis.io/commands/zremrangebylex> for more information.
.SS "zremrangebyrank"
.IX Subsection "zremrangebyrank"
.Vb 3
\&  $res     = $db\->zremrangebyrank($key, $start, $stop);
\&  $db      = $db\->zremrangebyrank($key, $start, $stop, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zremrangebyrank_p($key, $start, $stop);
.Ve
.PP
Remove all members in a sorted set within the given indexes.
.PP
See <https://redis.io/commands/zremrangebyrank> for more information.
.SS "zremrangebyscore"
.IX Subsection "zremrangebyscore"
.Vb 3
\&  $res     = $db\->zremrangebyscore($key, $min, $max);
\&  $db      = $db\->zremrangebyscore($key, $min, $max, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zremrangebyscore_p($key, $min, $max);
.Ve
.PP
Remove all members in a sorted set within the given scores.
.PP
See <https://redis.io/commands/zremrangebyscore> for more information.
.SS "zrevrange"
.IX Subsection "zrevrange"
.Vb 3
\&  $res     = $db\->zrevrange($key, $start, $stop, [WITHSCORES]);
\&  $db      = $db\->zrevrange($key, $start, $stop, [WITHSCORES], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zrevrange_p($key, $start, $stop, [WITHSCORES]);
.Ve
.PP
Return a range of members in a sorted set, by index, with scores ordered from high to low.
.PP
See <https://redis.io/commands/zrevrange> for more information.
.SS "zrevrangebylex"
.IX Subsection "zrevrangebylex"
.Vb 3
\&  $res     = $db\->zrevrangebylex($key, $max, $min, [LIMIT offset count]);
\&  $db      = $db\->zrevrangebylex($key, $max, $min, [LIMIT offset count], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zrevrangebylex_p($key, $max, $min, [LIMIT offset count]);
.Ve
.PP
Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.
.PP
See <https://redis.io/commands/zrevrangebylex> for more information.
.SS "zrevrangebyscore"
.IX Subsection "zrevrangebyscore"
.Vb 3
\&  $res     = $db\->zrevrangebyscore($key, $max, $min, [WITHSCORES], [LIMIT offset count]);
\&  $db      = $db\->zrevrangebyscore($key, $max, $min, [WITHSCORES], [LIMIT offset count], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zrevrangebyscore_p($key, $max, $min, [WITHSCORES], [LIMIT offset count]);
.Ve
.PP
Return a range of members in a sorted set, by score, with scores ordered from high to low.
.PP
See <https://redis.io/commands/zrevrangebyscore> for more information.
.SS "zrevrank"
.IX Subsection "zrevrank"
.Vb 3
\&  $res     = $db\->zrevrank($key, $member);
\&  $db      = $db\->zrevrank($key, $member, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zrevrank_p($key, $member);
.Ve
.PP
Determine the index of a member in a sorted set, with scores ordered from high to low.
.PP
See <https://redis.io/commands/zrevrank> for more information.
.SS "zscore"
.IX Subsection "zscore"
.Vb 3
\&  $res     = $db\->zscore($key, $member);
\&  $db      = $db\->zscore($key, $member, sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zscore_p($key, $member);
.Ve
.PP
Get the score associated with the given member in a sorted set.
.PP
See <https://redis.io/commands/zscore> for more information.
.SS "zunionstore"
.IX Subsection "zunionstore"
.Vb 3
\&  $res     = $db\->zunionstore($destination, $numkeys, $key [key ...], [WEIGHTS weight [weight ...]], [AGGREGATE SUM|MIN|MAX]);
\&  $db      = $db\->zunionstore($destination, $numkeys, $key [key ...], [WEIGHTS weight [weight ...]], [AGGREGATE SUM|MIN|MAX], sub { my ($db, $err, $res) = @_ });
\&  $promise = $db\->zunionstore_p($destination, $numkeys, $key [key ...], [WEIGHTS weight [weight ...]], [AGGREGATE SUM|MIN|MAX]);
.Ve
.PP
Add multiple sorted sets and store the resulting sorted set in a new key.
.PP
See <https://redis.io/commands/zunionstore> for more information.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojo::Redis.
