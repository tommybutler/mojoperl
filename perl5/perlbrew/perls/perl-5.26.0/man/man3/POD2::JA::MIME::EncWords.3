.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "POD2::JA::MIME::EncWords 3"
.TH POD2::JA::MIME::EncWords 3 "2013-10-29" "perl v5.26.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIME::EncWords~[ja] \- RFC 2047 encoded\-word 関連 (改良版)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fIMIME::EncWords は、RFC 2047 (旧 \s-1RFC 1522\s0)
の仕様により適合することをめざした MIME::Words の別実装です。
加えて、いくらかの改良がなされています。
以下の梗概と説明は、もとの MIME::Words から採ったものに、
改良点の説明 (\f(BI**\fI) および変更点の説明と明確化 (\f(BI*\fI)
を加えたものです。\fR
.PP
読み進める前に、MIME::Tools を見るべきだ。そうして、
あなたの成し遂げようとしていることのどこでこのモジュールを使うのかを、
理解してほしい。
いますぐ。待ってるから。
.PP
いいかな。はじめるよ...
.PP
.Vb 1
\&    use MIME::EncWords qw(:all);
\&
\&    ### 文字列を、キャラクタセットは無視してデコードした文字列にする:
\&    $decoded = decode_mimewords(
\&          \*(AqTo: =?ISO\-8859\-1?Q?Keld_J=F8rn_Simonsen?= <keld@dkuug.dk>\*(Aq,
\&          );
\&
\&    ### 文字列を、デコードされた [DATA,CHARSET] の対の配列にする:
\&    @decoded = decode_mimewords(
\&          \*(AqTo: =?ISO\-8859\-1?Q?Keld_J=F8rn_Simonsen?= <keld@dkuug.dk>\*(Aq,
\&          );
\&
\&    ### 単一の「安全でない語」をエンコードする:
\&    $encoded = encode_mimeword("\exABFran\exE7ois\exBB");
\&
\&    ### 文字列を、「安全でない語」を探しながらエンコードする:
\&    $encoded = encode_mimewords("Me and \exABFran\exE7ois\exBB in town");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
合衆国の諸君。このモジュールでいったい何をやらかそうというのか、
わからないかもしれないね。欧州、ロシア等の諸君なら、わかるだろう。\f(CW\*(C`(:\-)\*(C'\fR。
.PP
たとえば、これは有効な \s-1MIME\s0 ヘッダだ:
.PP
.Vb 6
\&      From: =?US\-ASCII?Q?Keith_Moore?= <moore@cs.utk.edu>
\&      To: =?ISO\-8859\-1?Q?Keld_J=F8rn_Simonsen?= <keld@dkuug.dk>
\&      CC: =?ISO\-8859\-1?Q?Andr=E9_?= Pirard <PIRARD@vm1.ulg.ac.be>
\&      Subject: =?ISO\-8859\-1?B?SWYgeW91IGNhbiByZWFkIHRoaXMgeW8=?=
\&       =?ISO\-8859\-2?B?dSB1bmRlcnN0YW5kIHRoZSBleGFtcGxlLg==?=
\&       =?US\-ASCII?Q?.._cool!?=
.Ve
.PP
これらのフィールドは、だいたいつぎのようにデコードできる:
.PP
.Vb 4
\&      From: Keith Moore <moore@cs.utk.edu>
\&      To: Keld Jørn Simonsen <keld@dkuug.dk>
\&      CC: André  Pirard <PIRARD@vm1.ulg.ac.be>
\&      Subject: If you can read this you understand the example... cool!
.Ve
.PP
\&\fB追補\fR: 合衆国、欧州の諸君。
このモジュールでいったいなにをやらかそうというのか、
わからないかもしれないね。東アジア等の諸君なら、わかるだろう。
\&\f(CW\*(C`(^_^)\*(C'\fR.
.PP
たとえば、これは有効な \s-1MIME\s0 ヘッダだ:
.PP
.Vb 2
\&      Subject: =?EUC\-KR?B?sNTAuLinKGxhemluZXNzKSwgwvzB9ri7seIoaW1w?=
\&       =?EUC\-KR?B?YXRpZW5jZSksILGzuLgoaHVicmlzKQ==?=
.Ve
.PP
これらのフィールドは、だいたいつぎのようにデコードできる:
.PP
.Vb 1
\&      Subject: 게으름(laziness), 참지말기(impatience), 교만(hubris)
.Ve
.SH "PUBLIC INTERFACE"
.IX Header "PUBLIC INTERFACE"
.IP "decode_mimewords \s-1ENCODED,\s0 [\s-1OPTS...\s0]" 4
.IX Item "decode_mimewords ENCODED, [OPTS...]"
\&\fI関数\fR。
文字列から \s-1RFC 2047\s0 スタイルの \*(L"Q\*(R" エンコーディング
(quoted-printable の一種) や \*(L"B\*(R" エンコーディング (base64)
を探し、それをデコードする。
.Sp
\&\fB配列コンテクストでは\fR、文字列 \s-1ENCODED\s0 をデコードした
\&\f(CW\*(C`[DATA, CHARSET]\*(C'\fR の対に分割し、そのリストを返す。
エンコードされていなかったデータは 1 要素の配列
\&\f(CW\*(C`[DATA]\*(C'\fR で返す (\s-1CHARSET\s0 は実質的に \f(CW\*(C`undef\*(C'\fR)。
.Sp
.Vb 4
\&    $enc = \*(Aq=?ISO\-8859\-1?Q?Keld_J=F8rn_Simonsen?= <keld@dkuug.dk>\*(Aq;
\&    foreach (decode_mimewords($enc)) {
\&        print "", ($_[1] || \*(AqUS\-ASCII\*(Aq), ": ", $_[0], "\en";
\&    }
.Ve
.Sp
\&\fB**\fR
ただし、隣り合う「encoded\-word」を、キャラクタセットがおなじなら連結する。
これは、マルチバイト列を安全に扱えるようにするためである。
.Sp
\&\fB**\fR
\&\s-1RFC2231\s0 第 5 節で定義している言語情報があれば、第 3 の要素として追加する。
.Sp
\&\fB*\fR
エンコードされていなかったデータの両端の空白文字は取り去らない。
これは、MIME::Words との互換性を保つためである。
.Sp
\&\fBスカラコンテクストでは\fR、上記のリストの \s-1DATA\s0 要素をすべて連結し、
それを返す。\fI注意: 情報の損失がある\fRので、
望んだ結果が得られ\fIない\fRかもしれない。
だが、文字列 \s-1ENCODED\s0
のすべての文字のキャラクタセットが同一だとわかっているのなら、
これは役に立つこともある。
(これを使う前に、\*(L"unmime\*(R" in MIME::WordDecoder を見てほしい。
これが望みのものかもしれない。)
\&\fB**\fR
下記の \*(L"Charset\*(R" も参照。
.Sp
構文エラーが発生すると、$@ にエラーの説明をセットするが、
解析はできるかぎり (ヘッダのデコードで得られた\fIなにか\fRを返すために)
続行する。
エラーが見つからなければ、$@ は偽となる。
.Sp
\&\fB*\fR
「encoded\-word」が壊れているときは、エンコードしたままのものを返す。
この場合、$@ をセットする。
.Sp
\&\s-1ENCODED\s0 に引き続く引数は、ハッシュによるオプションの定義とみなす。
\&\fB**\fR
Unicode/マルチバイト文字対応が有効になっていないとき
(\*(L"\s-1USE_ENCODE\*(R"\s0 in MIME::Charset 参照) は、
以下のオプションはなんの効果も持たない。
.RS 4
.IP "Charset \fB**\fR" 4
.IX Item "Charset **"
スカラコンテクストで、DATA 要素をこの名前のキャラクタセットで変換する。
このオプションに特殊値 \f(CW"_UNICODE_"\fR を指定すると、
返す値は Unicode 文字列となる。
.Sp
\&\fBNote\fR:
この仕様は、\fI\f(CI"_UNICODE_"\fI を指定したとき以外は\fR、
やはり情報の損失がある。
.IP "Detect7bit \fB**\fR" 4
.IX Item "Detect7bit **"
エンコードされていなかった部分の 7 ビットキャラクタセットを判別しようとする。
初期値は \f(CW"YES"\fR。
.IP "Mapping \fB**\fR" 4
.IX Item "Mapping **"
スカラコンテクストで、
キャラクタセットの名前に対して実際に使うマッピングを指定する。
\&\f(CW"EXTENDED"\fR は拡張マッピングを使う。
\&\f(CW"STANDARD"\fR は標準化されている厳密なマッピングを使う。
初期値は \f(CW"EXTENDED"\fR。
.RE
.RS 4
.RE
.IP "encode_mimeword \s-1RAW,\s0 [\s-1ENCODING\s0], [\s-1CHARSET\s0]" 4
.IX Item "encode_mimeword RAW, [ENCODING], [CHARSET]"
\&\fI関数\fR。
「安全でない」文字のある単一の「語」RAW をエンコードする。
「語」全体がエンコードされる。
.Sp
.Vb 2
\&    ### "«François»" をエンコードする:
\&    $encoded = encode_mimeword("\exABFran\exE7ois\exBB");
.Ve
.Sp
エンコーディング \s-1ENCODING\s0 を指定できる (\f(CW"Q"\fR または \f(CW"B"\fR)。
初期値は \f(CW"Q"\fR。
\&\fB**\fR
さらに、「特殊」な値も指定できる。
\&\f(CW"S"\fR は \f(CW"Q"\fR と \f(CW"B"\fR のうち短くなるほうを選ぶ。
.Sp
キャラクタセット \s-1CHARSET\s0 を指定できる。初期値は \f(CW\*(C`iso\-8859\-1\*(C'\fR。
.Sp
\&\fB*\fR
\&\f(CW"Q"\fR エンコーディングでは、空白を ``_'' でエスケープする。
.IP "encode_mimewords \s-1RAW,\s0 [\s-1OPTS\s0]" 4
.IX Item "encode_mimewords RAW, [OPTS]"
\&\fI関数\fR。
文字列 \s-1RAW\s0 から、「安全でない」文字の列を見つけてエンコードしようとする。
.Sp
.Vb 2
\&    ### 「安全でない語」のある文字列をエンコードする:
\&    $encoded = encode_mimewords("Me and \exABFran\exE7ois\exBB");
.Ve
.Sp
エンコードした文字列を返す。
.Sp
\&\fB**\fR
\&\s-1RAW\s0 は Unicode でもよい。ただし Unicode/マルチバイト対応が有効な場合
(\*(L"\s-1USE_ENCODE\*(R"\s0 in MIME::Charset 参照)。
さらに \s-1RAW\s0 は、\*(L"decode_mimewords\*(R"
が配列コンテクストで返すものへの参照でもよい。
後の場合は、\*(L"Charset\*(R" オプション (下記参照) が適宜上書きされる
(下の注も参照)。
.Sp
\&\fBNote\fR:
\&\fB*\fR
\&\s-1RAW\s0 が配列への参照であるときは、
隣り合う「encoded\-word」
(つまり、ASCII 以外のキャラクタセット要素のある要素)
を連結する。その上で、マルチバイト文字の文字境界を考慮しながら
(ただしこれは Unicode/マルチバイト対応が有効なときだけ)、分割する。
エンコードしないデータ部分は両端に空白文字が必要。
そうしなければ隣り合う「encoded\-word」に併合されてしまう。
.Sp
\&\s-1RAW\s0 に引き続く引数は、ハッシュによるオプションの定義とみなす:
.RS 4
.IP "Charset" 4
.IX Item "Charset"
「安全でない」ものはこのキャラクタセットでエンコードする。
初期値は '\s-1ISO\-8859\-1\s0' (別名 \*(L"Latin\-1\*(R")。
.IP "Detect7bit \fB**\fR" 4
.IX Item "Detect7bit **"
\&\*(L"Encoding\*(R" オプション (下記参照) が \f(CW"a"\fR に指定してあって \*(L"Charset\*(R"
オプションが不明なら、
\&\s-1RAW\s0 文字列の 7 ビットキャラクタセットを判別しようとする。
初期値は \f(CW"YES"\fR。
Unicode/マルチバイト文字対応が有効になっていないとき
(\*(L"\s-1USE_ENCODE\*(R"\s0 in MIME::Charset 参照) は、
このオプションはなんの効果も持たない。
.IP "Encoding" 4
.IX Item "Encoding"
使用するエンコーディング。\f(CW"q"\fR または \f(CW"b"\fR。
\&\fB**\fR
「特殊」な値も指定できる。\f(CW"a"\fR は推奨されるエンコーディングを自動選択する
(キャラクタセットに別のものが推奨されるときはキャラクタセット変換も行う。
MIME::Charset~[ja] 参照)。
\&\f(CW"s"\fR は \f(CW"q"\fR と \f(CW"b"\fR のうち短くなるほうを選ぶ。
\&\fBNote\fR:
\&\fB*\fR
リリース 1.005 で、初期値が \f(CW"q"\fR
(MIME::Words での初期値) から \f(CW"a"\fR に変わった。
.IP "Field" 4
.IX Item "Field"
この文字列を使うメールフィールドの名前。
\&\fB**\fR
ヘッダをエンコードする際には、最初の行でメールフィールド名の長さを考慮する。
.IP "Folding \fB**\fR" 4
.IX Item "Folding **"
エンコードする行を「行折り」する文字の列。初期値は \f(CW"\en"\fR。
空文字列 \f(CW""\fR を指定すると、行長 (下記 \*(L"MaxLineLen\*(R" 参照)
を超える「encoded\-word」を \s-1SPACE\s0 で分割するだけ。
.Sp
\&\fBNote\fR:
\&\fB*\fR
\&\s-1RFC 5322\s0 (旧 \s-1RFC 2822\s0) には、インターネットのメッセージでは行を
\&\s-1CRLF\s0 (\f(CW"\er\en"\fR) で区切ると明記してあるが、
このモジュールでは後方互換性を保つために \s-1LF\s0 (\f(CW"\en"\fR) を初期値としてきた。
初期値を使っている場合、
エンコードしたヘッダをセッションへと放つ前に、
改行文字の変換が必要になることもある。
.IP "Mapping \fB**\fR" 4
.IX Item "Mapping **"
キャラクタセットの名前に対して実際に使うマッピングを指定する。
\&\f(CW"EXTENDED"\fR は拡張マッピングを使う。
\&\f(CW"STANDARD"\fR は標準化されている厳密なマッピングを使う。
初期値は \f(CW"EXTENDED"\fR。
Unicode/マルチバイト文字対応が有効になっていないとき
(\*(L"\s-1USE_ENCODE\*(R"\s0 in MIME::Charset 参照) は、
このオプションはなんの効果も持たない。
.IP "MaxLineLen \fB**\fR" 4
.IX Item "MaxLineLen **"
行の最大長 (改行を除く)。
初期値は 76。
負の値は行長無制限を意味する (リリース 1.012.3 以降)。
.IP "Minimal \fB**\fR" 4
.IX Item "Minimal **"
エンコードするテキストの中の自然な語分離子 (要するに空白文字)
に注意を払う。
\&\f(CW"NO"\fR を指定すると、
このモジュールは空白文字を考慮せずにテキスト全体をエンコード
(エンコードが必要なら)
し、行長を超える「encoded\-word」は単にその長さによって分割される。
初期値は \f(CW"YES"\fR で、最小限の部分だけエンコードする。
\&\f(CW"DISPNAME"\fR を指定すると、RFC5322 (旧 RFC2822、RFC822)
のアドレス仕様 (3.4節) で述べている特殊文字を含む部分もエンコードする。
これはアドレスフィールド中の display-name をエンコードする際に有用である。
.Sp
\&\fBNote\fR:
リリース 0.040 で、初期値が \f(CW"YES"\fR に変わった。
MIME::Words との互換性を保つためである。
それ以前のリリースでは、このオプションは \f(CW"NO"\fR 固定であった。
.Sp
\&\fBNote\fR:
\&\f(CW"DISPNAME"\fR はリリース 1.012 で導入された。
.IP "Replacement \fB**\fR" 4
.IX Item "Replacement **"
\&\*(L"エラー処理\*(R" in MIME::Charset~[ja] 参照。
.RE
.RS 4
.RE
.SS "設定ファイル \fB**\fP"
.IX Subsection "設定ファイル **"
\&\*(L"decode_mimewords\*(R" ('Charset' オプションを除く) および
\&\*(L"encode_mimewords\*(R" のオプション引数の組み込み初期値は、
設定ファイルで上書きできる。
\&\fIMIME/Charset/Defaults.pm\fR と \fIMIME/EncWords/Defaults.pm\fR。
詳細は \fIMIME/EncWords/Defaults.pm.sample\fR を読んでほしい。
.SH "VERSION"
.IX Header "VERSION"
\&\f(CW$VERSION\fR 変数を参照してほしい。
.PP
このモジュールの開発版が
<http://hatuka.nezumi.nu/repos/MIME\-EncWords/>
にある。
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MIME::Charset~[ja],
MIME::Tools
.SH "AUTHORS"
.IX Header "AUTHORS"
\&\fIdecode_mimewords()\fR 関数の元の版は MIME::Words
モジュールから引き継いだもので、著者は以下のとおり:
    Eryq (\fIeryq@zeegee.com\fR), ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
    David F. Skoll (dfs@roaringpenguin.com) http://www.roaringpenguin.com
.PP
そのほかの部分は、次の者が書き直しあるいは加えた:
    Hatuka*nezumi \- \s-1IKEDA\s0 Soji <hatuka(at)nezumi.nu>.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
