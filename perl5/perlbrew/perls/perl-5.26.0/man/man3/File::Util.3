.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::Util 3"
.TH File::Util 3 "2017-08-04" "perl v5.26.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Util \- Easy, versatile, portable file handling
.SH "VERSION"
.IX Header "VERSION"
version 4.161950
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
File::Util provides a comprehensive toolbox of utilities to automate all
kinds of common tasks on files and directories.  Its purpose is to do so
in the most \fBportable\fR manner possible so that users of this module won't
have to worry about whether their programs will work on other operating systems
and/or architectures.  It works on Linux, Windows, Mac, \s-1BSD,\s0 Unix and others.
.PP
File::Util is written \fBpurely in Perl\fR, and requires no compiler or make
utility on your system in order to install and run it.  It loads a minimal
amount of code when used, only pulling in support for lesser-used methods
on demand.  It has no dependencies other than what comes installed with Perl
itself.
.PP
File::Util also aims to be as backward compatible as possible, running without
problems on Perl installations as old as 5.006.  You are encouraged to run
File::Util on Perl version 5.8 and above.
.PP
After browsing this document, please have a look at the other documentation.
\&\fI(See \s-1DOCUMENTATION\s0 section below.)\fR
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   # use File::Util in your program
\&   use File::Util;
\&
\&   # create a new File::Util object
\&   my $f = File::Util\->new();
\&
\&   # read file into a variable
\&   my $content = $f\->load_file( \*(Aqsome_file.txt\*(Aq );
\&
\&   # write content to a file
\&   $f\->write_file( \*(Aqsome_other_file.txt\*(Aq => \*(AqHello world!\*(Aq );
\&
\&   # get the contents of a directory, 3 levels deep
\&   my @songs = $f\->list_dir( \*(Aq~/Music\*(Aq => { recurse => 1, max_depth => 3 } );
.Ve
.SH "DOCUMENTATION"
.IX Header "DOCUMENTATION"
You can do much more with File::Util than the examples above.  For an
explanation of all the features available to you, take a look at these other
reference materials:
.IP "\fBExamples\fR" 4
.IX Item "Examples"
The File::Util::Manual::Examples document has a long list of small, reusable
code snippets and techniques to use in your own programs.  This is the \*(L"cheat
sheet\*(R", and is a great place to get started quickly.  Almost everything you
need is here.
.IP "\fBComplete \s-1API\s0 Reference\fR" 4
.IX Item "Complete API Reference"
The File::Util::Manual is the complete reference document explaining every
available feature and object method.  Use this to look up the full information
on any given feature when the examples aren't enough.
.IP "\fBCookbook\fR" 4
.IX Item "Cookbook"
The File::Util::Cookbook contains examples of complete, working programs
that use File::Util to easily accomplish tasks which require file handling.
.SH "BASIC USAGE"
.IX Header "BASIC USAGE"
.SS "Getting Started"
.IX Subsection "Getting Started"
.Vb 2
\&   # use File::Util in your program
\&   use File::Util;
\&
\&   # ...you can optionally enable File::Util\*(Aqs diagnostic error messages:
\&   # (see File::Util::Manual section regarding diagnostics)
\&   use File::Util qw( :diag );
\&
\&   # create a new File::Util object
\&   my $f = File::Util\->new();
\&
\&   # ...you can enable diagnostics for individual objects:
\&   $f = File::Util\->new( diag => 1 );
.Ve
.SS "File Operations"
.IX Subsection "File Operations"
.Vb 2
\&   # load file content into a scalar variable as raw text
\&   my $content = $f\->load_file( \*(Aqsomefile.txt\*(Aq );
\&
\&   # read a binary file the same way
\&   my $binary_content = $f\->load_file( \*(Aqbarking\-cat.mp4\*(Aq );
\&
\&   # write a raw text file
\&   $f\->write_file( \*(Aqsomefile.txt\*(Aq => $content );
\&
\&   # ...and write a binary file, using some other options as well
\&   $f\->write_file(
\&      \*(Aqllama.jpg\*(Aq => $picture_data => { binmode => 1, bitmask => oct 644 }
\&   );
\&
\&   # ...or write a file with UTF\-8 encoding (unicode support)
\&   $f\->write_file( \*(Aqencoded.txt\*(Aq => qq(\ex{c0}) => { binmode => \*(Aqutf8\*(Aq } );
\&
\&   # load a file into an array, line by line
\&   my @lines = $f\->load_file( \*(Aqfile.txt\*(Aq => { as_lines => 1 } );
\&
\&   # see if you have permission to write to a file, then append to it
\&   if ( $f\->is_writable( \*(Aqcaptains.log\*(Aq ) ) {
\&
\&      my $fh = $f\->open_handle( \*(Aqcaptains.log\*(Aq => \*(Aqappend\*(Aq );
\&
\&      print $fh "Captain\*(Aqs log, stardate 41153.7.  Our destination is...";
\&
\&      close $fh or die $!;
\&   }
\&   else { # ...or warn the crew
\&
\&      warn "Trouble on the bridge, the Captain can\*(Aqt access his log!";
\&   }
\&
\&   # get the number of lines in a file
\&   my $log_line_count = $f\->line_count( \*(Aq/var/log/messages\*(Aq );
.Ve
.SS "File Handles"
.IX Subsection "File Handles"
.Vb 2
\&   # get an open file handle for reading
\&   my $fh = $f\->open_handle( \*(AqIan likes cats.txt\*(Aq => \*(Aqread\*(Aq );
\&
\&   while ( my $line = <$fh> ) { # read the file, line by line
\&      # ... do stuff
\&   }
\&
\&   # get an open file handle for writing the same way
\&   $fh = $f\->open_handle( \*(AqJohn prefers dachshunds.txt\*(Aq => \*(Aqwrite\*(Aq );
\&
\&   # You add the option to turn on UTF\-8 strict encoding for your reads/writes
\&   $fh = $f\->open_handle(
\&      \*(AqJohn prefers dachshunds.txt\*(Aq => \*(Aqwrite\*(Aq => { binmode => \*(Aqutf8\*(Aq }
\&   );
\&
\&   print $fh "Bob is happy! \eN{U+263A}"; # << unicode smiley face!
\&
\&   # you can use sysopen to get low\-level with your file handles if needed
\&   $fh = $f\->open_handle(
\&      \*(Aqalderaan.txt\*(Aq => \*(Aqrwclobber\*(Aq => { use_sysopen => 1 }
\&   );
\&
\&   syswrite $fh, "that\*(Aqs no moon";
\&
\&   # ...You can use any of these syswrite modes with open_handle():
\&   # read, write, append, rwcreate, rwclobber, rwappend, rwupdate, and trunc
.Ve
.PP
\&\s-1PLEASE NOTE\s0 that as of Perl 5.23, it is deprecated to mix system \s-1IO\s0
(sysopen/syswrite/sysread/sysseek) with utf8 binmode (see perldoc perlport).
As such, File::Util will no longer allow you to do this after version
4.132140.  Please see notes on \s-1UTF\-8\s0 and encoding further below.
.PP
.Vb 4
\&   # ...THIS WILL NOW FAIL!
\&   $f\->open_handle(
\&      \*(Aqsomefile.txt\*(Aq => \*(Aqwrite\*(Aq => { use_sysopen => 1, binmode => \*(Aqutf8\*(Aq }
\&   );
.Ve
.SS "Directories"
.IX Subsection "Directories"
.Vb 2
\&   # get a listing of files, recursively, skipping directories
\&   my @files = $f\->list_dir( \*(Aq/var/tmp\*(Aq => { files_only => 1, recurse => 1 } );
\&
\&   # get a listing of text files, recursively
\&   my @textfiles = $f\->list_dir(
\&      \*(Aq/var/tmp\*(Aq => {
\&         files_match => qr/\e.txt$/,
\&         files_only  => 1,
\&         recurse     => 1,
\&      }
\&   );
\&
\&   # walk a directory, using an anonymous function or function ref as a callback
\&   $f\->list_dir( \*(Aq/home/larry\*(Aq => {
\&      recurse  => 1,
\&      callback => sub {
\&         my ( $selfdir, $subdirs, $files ) = @_;
\&         # do stuff ...
\&      },
\&   } );
\&
\&   # get an entire directory tree as a hierarchal datastructure reference
\&   my $tree = $f\->list_dir( \*(Aq/my/podcasts\*(Aq => { as_tree => 1 } );
.Ve
.SS "Getting Information About Files"
.IX Subsection "Getting Information About Files"
.Vb 1
\&   print \*(AqMy file has a bitmask of \*(Aq . $f\->bitmask( \*(Aqmy.file\*(Aq );
\&
\&   print \*(AqMy file is a \*(Aq . join(\*(Aq, \*(Aq, $f\->file_type( \*(Aqmy.file\*(Aq )) . " file.";
\&
\&   warn \*(AqThis file is binary!\*(Aq if $f\->is_bin( \*(Aqmy.file\*(Aq );
\&
\&   print \*(AqMy file was last modified on \*(Aq .
\&      scalar localtime $f\->last_modified( \*(Aqmy.file\*(Aq );
.Ve
.SS "Getting Information About Your System's \s-1IO\s0 Capabilities"
.IX Subsection "Getting Information About Your System's IO Capabilities"
.Vb 2
\&   # Does your running Perl support unicode?
\&   print \*(AqI support unicode\*(Aq if $f\->can_utf8;
\&
\&   # Can your system use file locking?
\&   print \*(AqI can use flock\*(Aq if $f\->can_flock;
\&
\&   # The correct directory separator for your system
\&   print \*(AqThe correct directory separator for this system is \*(Aq . $f\->SL;
\&
\&   # Does your platform require binmode for all IO?
\&   print \*(AqI always need binmode\*(Aq if $f\->needs_binmode;
\&
\&   # Is your system an EBCDIC platform?  (see perldoc perlebcdic)
\&   print \*(AqThis is an EBCDIC platform, so be careful!\*(Aq if $f\->EBCDIC;
.Ve
.PP
\&...See the File::Util::Manual for more details and features like advanced
pattern matching in directories, callbacks, directory walking, user-definable
error handlers, and more.
.SS "File Encoding and \s-1UTF\-8\s0"
.IX Subsection "File Encoding and UTF-8"
If you want to read/write in \s-1UTF\-8,\s0 you can do that:
.PP
.Vb 1
\&   $ftl\->load_file( \*(Aqfile.txt\*(Aq => $content => { binmode => \*(Aqutf8\*(Aq } );
\&
\&   $ftl\->write_file( \*(Aqfile.txt\*(Aq => $content => { binmode => \*(Aqutf8\*(Aq } );
\&
\&   $ftl\->open_handle( \*(Aqfile.txt\*(Aq => \*(Aqread\*(Aq => { binmode => \*(Aqutf8\*(Aq } );
\&
\&   # ...and so on
.Ve
.PP
Only use \f(CW\*(C`binmode => \*(Aqutf8\*(Aq\*(C'\fR for text.
.PP
Encoding and \s-1IO\s0 layers (sometimes called disciplines) can become complex.
It's not something you usually need to worry about unless you wish to
really fine tune File::Util's behavior beyond what are very suitable, portable
defaults, or accomplish very specific tasks like encoding conversions.
.PP
You're free to specify any binmode you like, or allow File::Util to use the
system's default \s-1IO\s0 layering.  It will automatically use the \*(L":raw\*(R" pseudo layer
when reading files that are binary, unless specifically told to use something
different.
.PP
You can control things as shown in the examples below:
.PP
.Vb 1
\&   $ftl\->load_file( \*(Aqfile.txt\*(Aq => $content => { binmode => SPEC } );
\&
\&   $ftl\->write_file( \*(Aqfile.txt\*(Aq => $content => { binmode => SPEC } );
\&
\&   $ftl\->open_handle( \*(Aqfile.txt\*(Aq => \*(Aqread\*(Aq => { binmode => SPEC } );
.Ve
.PP
\&...where \f(CW\*(C`SPEC\*(C'\fR is one or more of any supported \s-1IO\s0 layers on your system.
Examples might include:
.IP "\(bu" 4
\&\f(CW\*(Aq:raw\*(Aq\fR
.IP "\(bu" 4
\&\f(CW\*(Aq:unix\*(Aq\fR
.IP "\(bu" 4
\&\f(CW\*(Aq:crlf\*(Aq\fR
.IP "\(bu" 4
\&\f(CW\*(Aq:stdio\*(Aq\fR
.IP "\(bu" 4
\&\f(CW\*(Aq:encoding(ENCODING)\*(Aq\fR \fIwith \s-1ENCODING\s0's like iso\-8859\-1, shiftjis, etc\fR
.IP "\(bu" 4
\&...and much more
.PP
You can learn about the \s-1IO\s0 layers available to you and what they do in the
PerlIO perldoc.  Available options have increased over the years, and are
likely subject to continued evolution.  Consult the PerlIO and Encode
documentation as your authoritative source of info on what layers to use.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
File::Util consists of a set of smaller modules, but only loads the ones it
needs when it needs them.  It offers a comparatively fast load-up time, so using
File::Util doesn't bloat your code's resource footprint.
.PP
Additionally, File::Util has been optimized to run fast.  In many scenarios
it does more and still out-performs other popular \s-1IO\s0 modules.  Benchmarking tools
are included as part of the File::Util installation package.
.PP
\&\fI(See the benchmarking and profiling scripts\fR
\&\fIthat are included as part of this distribution.)\fR
.SH "METHODS"
.IX Header "METHODS"
File::Util exposes the following public methods.
.PP
\&\fBEach of which are covered in the File::Util::Manual\fR, which has more room for
the detailed explanation that is provided there.
.PP
This is just an itemized table of contents for \s-1HTML POD\s0 readers.  For those viewing
this document in a text terminal, open perldoc to the \f(CW\*(C`File::Util::Manual\*(C'\fR.
.IP "atomize_path         \fI(see atomize_path)\fR" 4
.IX Item "atomize_path (see atomize_path)"
.PD 0
.IP "bitmask              \fI(see bitmask)\fR" 4
.IX Item "bitmask (see bitmask)"
.IP "can_flock            \fI(see can_flock)\fR" 4
.IX Item "can_flock (see can_flock)"
.IP "can_utf8             \fI(see can_utf8)\fR" 4
.IX Item "can_utf8 (see can_utf8)"
.IP "created              \fI(see created)\fR" 4
.IX Item "created (see created)"
.IP "default_path         \fI(see default_path)\fR" 4
.IX Item "default_path (see default_path)"
.IP "diagnostic           \fI(see diagnostic)\fR" 4
.IX Item "diagnostic (see diagnostic)"
.IP "ebcdic               \fI(see ebcdic)\fR" 4
.IX Item "ebcdic (see ebcdic)"
.IP "escape_filename      \fI(see escape_filename)\fR" 4
.IX Item "escape_filename (see escape_filename)"
.IP "existent             \fI(see existent)\fR" 4
.IX Item "existent (see existent)"
.IP "file_type            \fI(see file_type)\fR" 4
.IX Item "file_type (see file_type)"
.IP "flock_rules          \fI(see flock_rules)\fR" 4
.IX Item "flock_rules (see flock_rules)"
.IP "is_bin               \fI(see is_bin)\fR" 4
.IX Item "is_bin (see is_bin)"
.IP "is_readable          \fI(see is_readable)\fR" 4
.IX Item "is_readable (see is_readable)"
.IP "is_writable          \fI(see is_writable)\fR" 4
.IX Item "is_writable (see is_writable)"
.IP "last_access          \fI(see last_access)\fR" 4
.IX Item "last_access (see last_access)"
.IP "last_changed         \fI(see last_changed)\fR" 4
.IX Item "last_changed (see last_changed)"
.IP "last_modified        \fI(see last_modified)\fR" 4
.IX Item "last_modified (see last_modified)"
.IP "line_count           \fI(see line_count)\fR" 4
.IX Item "line_count (see line_count)"
.IP "list_dir             \fI(see list_dir)\fR" 4
.IX Item "list_dir (see list_dir)"
.IP "load_dir             \fI(see load_dir)\fR" 4
.IX Item "load_dir (see load_dir)"
.IP "load_file            \fI(see load_file)\fR" 4
.IX Item "load_file (see load_file)"
.IP "make_dir             \fI(see make_dir)\fR" 4
.IX Item "make_dir (see make_dir)"
.IP "abort_depth          \fI(see abort_depth)\fR" 4
.IX Item "abort_depth (see abort_depth)"
.IP "needs_binmode        \fI(see needs_binmode)\fR" 4
.IX Item "needs_binmode (see needs_binmode)"
.IP "new                  \fI(see new)\fR" 4
.IX Item "new (see new)"
.IP "onfail               \fI(see onfail)\fR" 4
.IX Item "onfail (see onfail)"
.IP "open_handle          \fI(see open_handle)\fR" 4
.IX Item "open_handle (see open_handle)"
.IP "read_limit           \fI(see read_limit)\fR" 4
.IX Item "read_limit (see read_limit)"
.IP "return_path          \fI(see return_path)\fR" 4
.IX Item "return_path (see return_path)"
.IP "size                 \fI(see size)\fR" 4
.IX Item "size (see size)"
.IP "split_path           \fI(see split_path)\fR" 4
.IX Item "split_path (see split_path)"
.IP "strict_path          \fI(see strict_path)\fR" 4
.IX Item "strict_path (see strict_path)"
.IP "strip_path           \fI(see strip_path)\fR" 4
.IX Item "strip_path (see strip_path)"
.IP "touch                \fI(see touch)\fR" 4
.IX Item "touch (see touch)"
.IP "trunc                \fI(see trunc)\fR" 4
.IX Item "trunc (see trunc)"
.IP "unlock_open_handle   \fI(see unlock_open_handle)\fR" 4
.IX Item "unlock_open_handle (see unlock_open_handle)"
.IP "use_flock            \fI(see use_flock)\fR" 4
.IX Item "use_flock (see use_flock)"
.IP "valid_filename       \fI(see valid_filename)\fR" 4
.IX Item "valid_filename (see valid_filename)"
.IP "write_file           \fI(see write_file)\fR" 4
.IX Item "write_file (see write_file)"
.PD
.SH "EXPORTED SYMBOLS"
.IX Header "EXPORTED SYMBOLS"
Exports nothing by default.  File::Util fully respects your namespace.
You can, however, ask it for certain things (below).
.SS "\s-1EXPORT_OK\s0"
.IX Subsection "EXPORT_OK"
The following symbols comprise \f(CW@File::Util::EXPORT_OK\fR, and as such are
available for import to your namespace only upon request.  They can be
used either as object methods or like regular subroutines in your program.
.PP
.Vb 8
\&   \-  atomize_path      \-  can_flock         \-  can_utf8
\&   \-  created           \-  default_path      \-  diagnostic
\&   \-  ebcdic            \-  escape_filename   \-  existent
\&   \-  file_type         \-  is_bin            \-  is_readable
\&   \-  is_writable       \-  last_access       \-  last_changed
\&   \-  last_modified     \-  needs_binmode     \-  strict_path
\&   \-  return_path       \-  size              \-  split_path
\&   \-  strip_path        \-  valid_filename    \-  NL and S L
.Ve
.PP
To get any of these functions/symbols into your namespace without having
to use them as object methods, use this kind of syntax:
.PP
.Vb 1
\&   use File::Util qw( strip_path return_path existent size );
\&
\&   my $file  = $ARGV[0];
\&   my $fname = strip_path( $file );
\&   my $path  = return_path( $file );
\&   my $size  = size( $file );
\&
\&   print qq(File "$fname" exists in "$path", and is $size bytes in size)
\&      if existent( $file );
.Ve
.SS "\s-1EXPORT_TAGS\s0"
.IX Subsection "EXPORT_TAGS"
.Vb 1
\&   :all (imports all of @File::Util::EXPORT_OK to your namespace)
\&
\&   :diag (imports nothing to your namespace, it just enables diagnostics)
.Ve
.PP
You can use these tags alone, or in combination with other symbols as
shown above.
.SH "PREREQUISITES"
.IX Header "PREREQUISITES"
.IP "None.  There are no external prerequisite modules." 4
.IX Item "None. There are no external prerequisite modules."
File::Util only depends on modules that are part of the Core Perl distribution,
and you don't need a compiler on your system to install it.
.IP "File::Util recommends Perl 5.8.1 or better ..." 4
.IX Item "File::Util recommends Perl 5.8.1 or better ..."
You can technically run File::Util on older versions of Perl 5, but it isn't
recommended, especially if you want unicode support and wish to take advantage
of File::Util's ability to read and write files using \s-1UTF\-8\s0 encoding.
.Sp
Unicode::UTF8 is also recommended and helps speed things up
in several places where you might choose to use unicode as described
elsewhere in the File::Util::Manual.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
To install this module type the following at the command prompt:
.PP
.Vb 4
\&   perl Build.PL
\&   perl Build
\&   perl Build test
\&   sudo perl Build install
.Ve
.PP
On Windows systems, the \*(L"sudo\*(R" part of the command may be omitted, but you
will need to run the rest of the install command with Administrative privileges
.SH "BUGS"
.IX Header "BUGS"
Send bug reports and patches to the \s-1CPAN\s0 Bug Tracker for File::Util at
rt.cpan.org <https://rt.cpan.org/Dist/Display.html?Name=File%3A%3AUtil>
.SH "SUPPORT"
.IX Header "SUPPORT"
If you want to get help, contact the authors (links below in \s-1AUTHORS\s0 section)
.PP
I fully endorse <http://www.perlmonks.org> as an excellent source of help
with Perl in general.
.SH "CONTRIBUTING"
.IX Header "CONTRIBUTING"
The project website for File::Util is at
<https://github.com/tommybutler/file\-util/wiki>
.PP
The git repository for File::Util is on Github at
<https://github.com/tommybutler/file\-util>
.PP
Clone it at <git://github.com/tommybutler/file\-util.git>
.PP
This project was a private endeavor for too long so don't hesitate to pitch in.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
The following people have contributed to File::Util in the form of feedback,
encouragement, recommendations, testing, or assistance with problems either
on or offline in one form or another.  Listed in no particular order:
.IP "\(bu" 4
John Fields <jfields.cpan.org@spammenot.com>
.IP "\(bu" 4
BrowserUk <browseruk@cpan.org>
.IP "\(bu" 4
Ricardo \s-1SIGNES\s0 <rjbs@cpan.org>
.IP "\(bu" 4
Matt S Trout <perl\-stuff@trout.me.uk>
.IP "\(bu" 4
Nicholas Perez <nperez@cpan.org>
.IP "\(bu" 4
David Golden <dagolden@cpan.org>
.SH "AUTHORS"
.IX Header "AUTHORS"
Tommy Butler <http://www.atrixnet.com/contact>
.PP
Others Welcome!
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright(C) 2001\-2013, Tommy Butler.  All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software, you may redistribute it and/or modify it
under the same terms as Perl itself. For more details, see the full text of
the \s-1LICENSE\s0 file that is included in this distribution.
.SH "LIMITATION OF WARRANTY"
.IX Header "LIMITATION OF WARRANTY"
This software is distributed in the hope that it will be useful, but without
any warranty; without even the implied warranty of merchantability or fitness
for a particular purpose.
.PP
This disclaimer applies to every part of the File::Util distribution.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The rest of the documentation:
File::Util::Manual, File::Util::Manual::Examples, File::Util::Cookbook
.PP
Other Useful Modules that do similar things:
File::Slurp, File::Spec, File::Find::Rule, Path::Class,
Path::Tiny
