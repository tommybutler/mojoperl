.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Time::ParseDate 3"
.TH Time::ParseDate 3 "2015-10-30" "perl v5.26.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Time::ParseDate \-\- date parsing both relative and absolute
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&        use Time::ParseDate;
\&        $seconds_since_jan1_1970 = parsedate("12/11/94 2pm", NO_RELATIVE => 1)
\&        $seconds_since_jan1_1970 = parsedate("12/11/94 2pm", %options)
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
Date parsing can also use options.  The options are as follows:
.PP
.Vb 10
\&        FUZZY   \-> it\*(Aqs okay not to parse the entire date string
\&        NOW     \-> the "current" time for relative times (defaults to time())
\&        ZONE    \-> local timezone (defaults to $ENV{TZ})
\&        WHOLE   \-> the whole input string must be parsed
\&        GMT     \-> input time is assumed to be GMT, not localtime
\&        UK      \-> prefer UK style dates (dd/mm over mm/dd)
\&        DATE_REQUIRED \-> do not default the date
\&        TIME_REQUIRED \-> do not default the time
\&        NO_RELATIVE \-> input time is not relative to NOW
\&        TIMEFIRST \-> try parsing time before date [not default]
\&        PREFER_PAST \-> when year or day of week is ambiguous, assume past
\&        PREFER_FUTURE \-> when year or day of week is ambiguous, assume future
\&        SUBSECOND \-> parse fraction seconds
\&        VALIDATE \-> only accept normal values for HHMMSS, YYMMDD.  Otherwise
\&                days like \-1 might give the last day of the previous month.
.Ve
.SH "DATE FORMATS RECOGNIZED"
.IX Header "DATE FORMATS RECOGNIZED"
.SS "Absolute date formats"
.IX Subsection "Absolute date formats"
.Vb 10
\&        Dow, dd Mon yy
\&        Dow, dd Mon yyyy
\&        Dow, dd Mon
\&        dd Mon yy
\&        dd Mon yyyy
\&        Month day{st,nd,rd,th}, year
\&        Month day{st,nd,rd,th}
\&        Mon dd yyyy
\&        yyyy/mm/dd
\&        yyyy\-mm\-dd      (usually the best date specification syntax)
\&        yyyy/mm
\&        mm/dd/yy
\&        mm/dd/yyyy
\&        mm/yy
\&        yy/mm      (only if year > 12, or > 31 if UK)
\&        yy/mm/dd   (only if year > 12 and day < 32, or year > 31 if UK)
\&        dd/mm/yy   (only if UK, or an invalid mm/dd/yy or yy/mm/dd)
\&        dd/mm/yyyy (only if UK, or an invalid mm/dd/yyyy)
\&        dd/mm      (only if UK, or an invalid mm/dd)
.Ve
.SS "Relative date formats:"
.IX Subsection "Relative date formats:"
.Vb 10
\&        count "days"
\&        count "weeks"
\&        count "months"
\&        count "years"
\&        Dow "after next"
\&        Dow "before last"
\&        Dow                     (requires PREFER_PAST or PREFER_FUTURE)
\&        "next" Dow
\&        "tomorrow"
\&        "today"
\&        "yesterday"
\&        "last" dow
\&        "last week"
\&        "now"
\&        "now" "+" count units
\&        "now" "\-" count units
\&        "+" count units         
\&        "\-" count units
\&        count units "ago"
.Ve
.SS "Absolute time formats:"
.IX Subsection "Absolute time formats:"
.Vb 7
\&        hh:mm:ss[.ddd] 
\&        hh:mm 
\&        hh:mm[AP]M
\&        hh[AP]M
\&        hhmmss[[AP]M] 
\&        "noon"
\&        "midnight"
.Ve
.SS "Relative time formats:"
.IX Subsection "Relative time formats:"
.Vb 8
\&        count "minutes"         (count can be franctional "1.5" or "1 1/2")
\&        count "seconds"
\&        count "hours"
\&        "+" count units
\&        "+" count
\&        "\-" count units
\&        "\-" count
\&        count units "ago"
.Ve
.SS "Timezone formats:"
.IX Subsection "Timezone formats:"
.Vb 4
\&        [+\-]dddd
\&        GMT[+\-]d+
\&        [+\-]dddd (TZN)
\&        TZN
.Ve
.SS "Special formats:"
.IX Subsection "Special formats:"
.Vb 2
\&        [ d]d/Mon/yyyy:hh:mm:ss [[+\-]dddd]
\&        yy/mm/dd.hh:mm
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module recognizes the above date/time formats.   Usually a
date and a time are specified.  There are numerous options for 
controlling what is recognized and what is not.
.PP
The return code is always the time in seconds since January 1st, 1970
or undef if it was unable to parse the time.
.PP
If a timezone is specified it must be after the time.  Year specifications
can be tacked onto the end of absolute times.
.PP
If \f(CW\*(C`parsedate()\*(C'\fR is called from array context, then it will return two
elements.  On successful parses, it will return the seconds and what 
remains of its input string.  On unsuccessful parses, it will return
\&\f(CW\*(C`undef\*(C'\fR and an error string.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 9
\&        $seconds = parsedate("Mon Jan  2 04:24:27 1995");
\&        $seconds = parsedate("Tue Apr 4 00:22:12 PDT 1995");
\&        $seconds = parsedate("04.04.95 00:22", ZONE => PDT);
\&        $seconds = parsedate("Jan 1 1999 11:23:34.578", SUBSECOND => 1);
\&        $seconds = parsedate("122212 950404", ZONE => PDT, TIMEFIRST => 1);
\&        $seconds = parsedate("+3 secs", NOW => 796978800);
\&        $seconds = parsedate("2 months", NOW => 796720932);
\&        $seconds = parsedate("last Tuesday");
\&        $seconds = parsedate("Sunday before last");
\&
\&        ($seconds, $remaining) = parsedate("today is the day");
\&        ($seconds, $error) = parsedate("today is", WHOLE=>1);
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 1996\-2010 David Muir Sharnoff.  
Copyright (C) 2011 Google, Inc.  
License hereby
granted for anyone to use, modify or redistribute this module at
their own risk.  Please feed useful changes back to cpan@dave.sharnoff.org.
