.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Crypt::Eksblowfish::Subkeyed 3"
.TH Crypt::Eksblowfish::Subkeyed 3 "2018-08-13" "perl v5.26.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::Eksblowfish::Subkeyed \- Blowfish/Eksblowfish with access to subkeys
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Crypt::Eksblowfish::Subkeyed;
\&
\&        $block_size = Crypt::Eksblowfish::Subkeyed\->blocksize;
\&
\&        $cipher = Crypt::Eksblowfish::Subkeyed
\&                        \->new_from_subkeys(\e@p_array, \e@s_boxes);
\&        $cipher = Crypt::Eksblowfish::Subkeyed\->new_initial;
\&
\&        $block_size = $cipher\->blocksize;
\&        $ciphertext = $cipher\->encrypt($plaintext);
\&        $plaintext = $cipher\->decrypt($ciphertext);
\&
\&        $p_array = $cipher\->p_array;
\&        $s_boxes = $cipher\->s_boxes;
\&        if($cipher\->is_weak) { ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of this class encapsulates a keyed instance of the Blowfish
or Eksblowfish block cipher, ready to encrypt and decrypt.  Normally
this class will not be used directly, but through subclasses such as
Crypt::Eksblowfish.
.PP
Eksblowfish is a variant of the Blowfish cipher with a modified key setup
algorithm.  This class doesn't implement either form of key setup, but
only provides the actual encryption and decryption parts of the ciphers.
This part is shared between Blowfish and Eksblowfish, and also any other
cipher that uses the core of Blowfish but supplies its own key setup.
This class has \*(L"Eksblowfish\*(R" in its name rather than \*(L"Blowfish\*(R" merely
due to the historical accident that it is derived from the encryption
engine that was used to implement Eksblowfish.
.PP
The key setup phase of a block cipher, also known as the \*(L"key
schedule\*(R", produces a set of \*(L"subkeys\*(R", which are somewhat like ordinary
cryptographic keys (which are the input to the key setup algorithm) but
are much larger.  In some block ciphers the subkeys also have special
interrelationships.  In Blowfish the subkeys consist of a \*(L"P\-array\*(R" of 18
32\-bit entries (one per encryption round plus two more) and four \*(L"S\-boxes\*(R"
(\*(L"S\*(R" is for \*(L"substitution\*(R") each of which consists of 256 32\-bit entries.
There is no special relationship between the values of the subkeys.
.PP
Methods in this class allow a cipher object to be constructed from
a full set of subkeys, and for the subkeys to be extracted from a
cipher object.  Normal users don't need to do either of these things.
It's mainly useful when devising a new key schedule to stick onto the
Blowfish core, or when performing cryptanalysis of the cipher algorithm.
.PP
Generating subkeys directly by a strong random process, rather than by
expansion of a smaller random key, is an expensive and slightly bizarre
way to get greater cryptographic strength from a cipher algorithm.
It eliminates attacks on the key schedule, and yields the full strength
of the core algorithm.  However, this is always a lot less strength than
the amount of subkey material, whereas a normal key schedule is designed
to yield strength equal to the length of the (much shorter) key.  Also,
any non-randomness in the source of the subkey material is likely to
lead to a cryptographic weakness, whereas a key schedule conceals any
non-randomness in the choice of the key.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.IP "Crypt::Eksblowfish::Subkeyed\->blocksize" 4
.IX Item "Crypt::Eksblowfish::Subkeyed->blocksize"
Returns 8, indicating the Eksblowfish block size of 8 octets.  This method
may be called on either the class or an instance.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "Crypt::Eksblowfish::Subkeyed\->new_from_subkeys(\s-1ROUND_KEYS, SBOXES\s0)" 4
.IX Item "Crypt::Eksblowfish::Subkeyed->new_from_subkeys(ROUND_KEYS, SBOXES)"
Creates a new Blowfish cipher object encapsulating the supplied subkeys.
\&\s-1ROUND_KEYS\s0 must be a reference to an array of 18 32\-bit integers.
\&\s-1SBOXES\s0 must be a reference to an array of four references to 256\-element
arrays of 32\-bit integers.  These subkeys are used in the standard order
for Blowfish.
.IP "Crypt::Eksblowfish::Subkeyed\->new_initial" 4
.IX Item "Crypt::Eksblowfish::Subkeyed->new_initial"
The standard Blowfish key schedule is an iterative process, which uses
the cipher algorithm to progressively replace subkeys, thus mutating the
cipher for subsequent iterations of keying.  The Eksblowfish key schedule
works similarly, but with a lot more iterations.  In both cases, the
key setup algorithm begins with a standard set of subkeys, consisting
of the initial bits of the fractional part of pi.  This constructor
creates and returns a Blowfish block cipher object with that standard
initial set of subkeys.  This is probably useful only to designers of
novel key schedules.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$cipher\->blocksize" 4
.el .IP "\f(CW$cipher\fR\->blocksize" 4
.IX Item "$cipher->blocksize"
Returns 8, indicating the Eksblowfish block size of 8 octets.  This method
may be called on either the class or an instance.
.ie n .IP "$cipher\->encrypt(\s-1PLAINTEXT\s0)" 4
.el .IP "\f(CW$cipher\fR\->encrypt(\s-1PLAINTEXT\s0)" 4
.IX Item "$cipher->encrypt(PLAINTEXT)"
\&\s-1PLAINTEXT\s0 must be exactly eight octets.  The block is encrypted, and
the ciphertext is returned.
.ie n .IP "$cipher\->decrypt(\s-1CIPHERTEXT\s0)" 4
.el .IP "\f(CW$cipher\fR\->decrypt(\s-1CIPHERTEXT\s0)" 4
.IX Item "$cipher->decrypt(CIPHERTEXT)"
\&\s-1CIPHERTEXT\s0 must be exactly eight octets.  The block is decrypted, and
the plaintext is returned.
.ie n .IP "$cipher\->p_array" 4
.el .IP "\f(CW$cipher\fR\->p_array" 4
.IX Item "$cipher->p_array"
Returns a reference to an 18\-element array containing the 32\-bit round
keys used in this cipher object.
.ie n .IP "$cipher\->s_boxes" 4
.el .IP "\f(CW$cipher\fR\->s_boxes" 4
.IX Item "$cipher->s_boxes"
Returns a reference to a 4\-element array containing the S\-boxes used in
this cipher object.  Each S\-box is a 256\-element array of 32\-bit entries.
.ie n .IP "$cipher\->is_weak" 4
.el .IP "\f(CW$cipher\fR\->is_weak" 4
.IX Item "$cipher->is_weak"
Returns a truth value indicating whether this is a weak key.  A key is
considered weak if any S\-box contains a pair of identical entries
(in any positions).  When Blowfish is used with such an S\-box, certain
cryptographic attacks are possible that are not possible against most
keys.  The current (as of 2007) cryptanalytic results on Blowfish do
not include an actual break of the algorithm when weak keys are used,
but if a break is ever developed then it is likely to be achieved for
weak keys before it is achieved for the general case.
.Sp
About one key in every 2^15 is weak (if the keys are randomly selected).
Because of the complicated key schedule in standard Blowfish it is not
possible to predict which keys will be weak without first performing the
full key setup, which is why this is a method on the keyed cipher object.
In some uses of Blowfish it may be desired to avoid weak keys; if so,
check using this method and generate a new random key when a weak key
is detected.  Bruce Schneier, the designer of Blowfish, says it is
probably not worth avoiding weak keys.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Crypt::Eksblowfish,
Crypt::Eksblowfish::Blowfish,
<http://www.schneier.com/paper\-blowfish\-fse.html>
.SH "AUTHOR"
.IX Header "AUTHOR"
Eksblowfish guts originally by Solar Designer (solar at openwall.com).
.PP
Modifications and Perl interface by Andrew Main (Zefram)
<zefram@fysh.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011
Andrew Main (Zefram) <zefram@fysh.org>
.PP
The original Eksblowfish code (in the form of \fIcrypt()\fR) from which
this module is derived is in the public domain.  It may be found at
<http://www.openwall.com/crypt/>.
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
